<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>sundusk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="sundusk">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sundusk">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sundusk">
  
    <link rel="alternate" href="/atom.xml" title="sundusk" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sundusk</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python3基本语法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/06/Python3基本语法/" class="article-date">
  <time datetime="2018-04-06T05:19:34.000Z" itemprop="datePublished">2018-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/06/Python3基本语法/">Python3基本语法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/06/Python3基本语法/" data-id="cjfni46wj00009fdledpfev00" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-移动硬盘修复" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/04/移动硬盘修复/" class="article-date">
  <time datetime="2018-04-04T07:29:08.000Z" itemprop="datePublished">2018-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/04/移动硬盘修复/">移动硬盘修复</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="经常用的一块移动硬盘，但有一次在复制文件的时候突然断开了，然后再连接电脑就显示盘符打不开了，而且只要双击或者右键这个盘符就会一直卡住，整个我的电脑都打不开了，必须拔出移动硬盘才能退出，否则一直卡那里，根本无法打开其他文件夹了，以为是usb线的问题，换了还是一样不行，换了几个usb口问题依旧，能看见盘符但打不开。"><a href="#经常用的一块移动硬盘，但有一次在复制文件的时候突然断开了，然后再连接电脑就显示盘符打不开了，而且只要双击或者右键这个盘符就会一直卡住，整个我的电脑都打不开了，必须拔出移动硬盘才能退出，否则一直卡那里，根本无法打开其他文件夹了，以为是usb线的问题，换了还是一样不行，换了几个usb口问题依旧，能看见盘符但打不开。" class="headerlink" title="经常用的一块移动硬盘，但有一次在复制文件的时候突然断开了，然后再连接电脑就显示盘符打不开了，而且只要双击或者右键这个盘符就会一直卡住，整个我的电脑都打不开了，必须拔出移动硬盘才能退出，否则一直卡那里，根本无法打开其他文件夹了，以为是usb线的问题，换了还是一样不行，换了几个usb口问题依旧，能看见盘符但打不开。"></a>经常用的一块移动硬盘，但有一次在复制文件的时候突然断开了，然后再连接电脑就显示盘符打不开了，而且只要双击或者右键这个盘符就会一直卡住，整个我的电脑都打不开了，必须拔出移动硬盘才能退出，否则一直卡那里，根本无法打开其他文件夹了，以为是usb线的问题，换了还是一样不行，换了几个usb口问题依旧，能看见盘符但打不开。</h6><p>解决办法：</p>
<ul>
<li>方案一    <ul>
<li>点击左下角的开始按钮”然后点击运行按钮，然后输入cmd，这个命令是打开dos窗口，或者直接快捷键“Win + R”然后输入cmd。</li>
<li>然后会弹出一个dos窗口如下，输入“chkdsk H:/f”意思是修复H盘的意思，注意H之前有一个空格，如果你的移动硬盘是G盘就应该是“chkdsk G:/f”，输入完毕后点击确定，然后系统开始修复移动硬盘，过一会儿就修复完成了。</li>
<li>然后打开“我的电脑”就会发现里面不再显示H：这个盘符了，而是显示出硬盘的名字了，而且能进入硬盘里面了，最重要的是数据都在，一个也没有损坏也没有丢失。</li>
<li>另外如果上面的修复后，虽然能打开，但里面还是有某个文件夹打不开的话，尝试使用“chkdsk H:/r”命令来修复，它的意思是会检测坏道，不止是修复数据。</li>
<li><strong>重点： 如果windows系统使用这个命令还是不成功的话</strong>，可以尝试使用苹果电脑，没有的话去苹果商店说明情况会让你使用一下，修复方式一样，也就是说苹果电脑的终端也一样的输入“chkdsk H:/f”，有人遇到win的系统修复不了，但苹果mac电脑能修复成功，数据都还在。</li>
</ul>
</li>
<li>方法二<ul>
<li>如果觉得dos命令太复杂的话，或者你是win10系统的话，可以使用下面的方式来解决。<ul>
<li>利用系统自带的“磁盘查错”功能来修复可移动磁盘。</li>
<li>右击“可移动磁盘”盘符，从其右侧菜单中选择“属性”项。</li>
<li>然后再弹出的窗口里，选择第二个工具选项，然后点击检查按钮。</li>
<li>然后在打开的页面上点击 修复驱动器按钮，系统就会自动修复移动硬盘了，我们只需要等待。</li>
<li>修复成功后会返回信息，这时候我们再去我的电脑打开移动硬盘看看数据吧，应该是修复好了。</li>
</ul>
</li>
</ul>
</li>
<li>方法三<ul>
<li>驱动故障导致的移动硬盘打不开，这时候只需要鼠标右键我的电脑，点击管理，然后选择设备管理器，可以看到右侧设备里有未知设备，这就说明移动硬盘没有安装正确。</li>
<li>这时候我们需要借助第三方软件，驱动人生来更新修复移动硬盘的驱动。</li>
<li>然后就会直接等待修复成功，一切都是自带修的，我们只需要点击几个按钮就行。</li>
<li>最后提示要重启电脑，按照做就行，然后你就会发现我的电脑里的移动硬盘已经可以打开了，里面的数据也没损失。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/04/移动硬盘修复/" data-id="cjfni46wu00049fdlrhfdtzd2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中pch文件的设置" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/04/iOS中pch文件的设置/" class="article-date">
  <time datetime="2018-04-04T00:26:22.000Z" itemprop="datePublished">2018-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/04/iOS中pch文件的设置/">iOS中pch文件的设置</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="pch文件是什么"><a href="#pch文件是什么" class="headerlink" title="pch文件是什么"></a>pch文件是什么</h2><p>​    预编译头文件(一般扩展名为.PCH),是把一个工程中较稳定的代码预先编译好放在一个文件(.PCH)里,它们在整个工程中是较为稳定的,即在工程开发过程中不会经常被修改的代码。在我的理解里是把一些宏定义（kScreenW等），一些要在多个类中使用的头文件在此文件中书写。简单来说，在.pch文件中定义的宏定义会作用到项目中的所有文件。</p>
<h2 id="pch文件的作用"><a href="#pch文件的作用" class="headerlink" title="pch文件的作用"></a>pch文件的作用</h2><p>   对于xcode6以后创建工程不在自动添加.pch文件了，很多资料认为.pch文件会影响效率。我觉得.pch文件总体上会加速编译，因为xcode会对.pch文件中的定义预编译并缓存。之所以减慢编译速度应该是因为很多开发者使用方式不对吧。<br>   我们可以想到.pch是把双刃剑，提供便利性的同时如果使用不当可能增加Build的时间。</p>
<p>   因此我们在使用时，要注意以下几点：</p>
<ul>
<li>不要把绝大多数甚至是所有的宏定义放进来。</li>
<li>在某个类或者某几个类中使用的宏定义别放进来。</li>
<li>放置公用性高的头文件，比如使用率较高的fundation框架,第三方库头文件。</li>
<li>为了整洁性的要求，建议把公用性低的宏定义整理到某个头文件再将该头文件写入.pch文件。</li>
</ul>
<h2 id="如何设置pch文件"><a href="#如何设置pch文件" class="headerlink" title="如何设置pch文件"></a>如何设置pch文件</h2><p>1.新建文件，选择PCH File<br>2.点击项目，选择Bulid Settings，在搜索框中写入Prefix Header<br>3.找到这一栏Precompile Prefix Header，将NO改为Yes<br>4.在Prefix Header这一栏后面双击出现白框，输入$(SRCROOT)/项目名/Prefix.pch 。<br>注意这里的SRCROOT一定要大写，项目名不能出现汉字。 </p>
<p>至此，就可以在pch文件中写入宏定义,以及导入一些头文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define kScreenW [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define kScreenH [UIScreen mainScreen].bounds.size.height12</span><br></pre></td></tr></table></figure>
<p>这样在所有的项目文件里都可以直接使用kScreenW来代替[UIScreen mainScreen].bounds.size.width，是不是很简便？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/04/iOS中pch文件的设置/" data-id="cjfni46wn00019fdl4wttlv9g" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/04/面试题总结/" class="article-date">
  <time datetime="2018-04-03T21:17:14.000Z" itemprop="datePublished">2018-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/04/面试题总结/">面试题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="内存管理方面（ARC、MRC、autorelease、autoreleasepool）"><a href="#内存管理方面（ARC、MRC、autorelease、autoreleasepool）" class="headerlink" title="内存管理方面（ARC、MRC、autorelease、autoreleasepool）"></a>内存管理方面（ARC、MRC、autorelease、autoreleasepool）</h4><h5 id="1-怎么保证多人开发进行内存泄露的检查"><a href="#1-怎么保证多人开发进行内存泄露的检查" class="headerlink" title="1.怎么保证多人开发进行内存泄露的检查"></a>1.怎么保证多人开发进行内存泄露的检查</h5><ul>
<li>使用Analyze进行代码的静态分析</li>
<li>为避免不必要的麻烦, 多人开发时尽量使用ARC</li>
</ul>
<h5 id="2-非自动内存管理情况下怎么做单例模式"><a href="#2-非自动内存管理情况下怎么做单例模式" class="headerlink" title="2.非自动内存管理情况下怎么做单例模式"></a>2.非自动内存管理情况下怎么做单例模式</h5><p>创建单例设计模式的基本步骤</p>
<ul>
<li>声明一个单件对象的静态实例,并初始化为nil。</li>
<li>创建一个类的类工厂方法,当且仅当这个类的实例为nil时生成一个该类的实例</li>
<li>实现NScopying协议, 覆盖allocWithZone:方法,确保用户在直接分配和初始化对象时,不会产 生另一个对象。</li>
<li>覆盖release、autorelease、retain、retainCount方法, 以此确保单例的状态。</li>
<li>在多线程的环境中,注意使用@synchronized关键字或GCD,确保静态实例被正确的创建和初始化</li>
</ul>
<h5 id="3-对于类方法（静态方法）默认是-autorelease-的。所有类方法都会这样吗？"><a href="#3-对于类方法（静态方法）默认是-autorelease-的。所有类方法都会这样吗？" class="headerlink" title="3.对于类方法（静态方法）默认是 autorelease 的。所有类方法都会这样吗？"></a>3.对于类方法（静态方法）默认是 autorelease 的。所有类方法都会这样吗？</h5><ul>
<li>系统自带的绝大数类方法返回的对象,都是经过autorelease的</li>
</ul>
<h5 id="4-block-在-ARC-中和-MRC-中的用法有什么区别-需要注意什么"><a href="#4-block-在-ARC-中和-MRC-中的用法有什么区别-需要注意什么" class="headerlink" title="4.block 在 ARC 中和 MRC 中的用法有什么区别,需要注意什么"></a>4.block 在 ARC 中和 MRC 中的用法有什么区别,需要注意什么</h5><ul>
<li>对于没有引用外部变量的Block，无论在ARC还是非ARC下，类型都是<strong>NSGlobalBlock</strong>，这种类型的block可以理解成一种全局的block，不需要考虑作用域问题。同时，对他进行Copy或者Retain操作也是无效的</li>
<li>应注意避免循环引用</li>
</ul>
<h5 id="5-什么情况下会发生内存泄漏和内存溢出？"><a href="#5-什么情况下会发生内存泄漏和内存溢出？" class="headerlink" title="5.什么情况下会发生内存泄漏和内存溢出？"></a>5.什么情况下会发生内存泄漏和内存溢出？</h5><ul>
<li>当程序在申请内存后，无法释放已申请的内存空间(例如一个对象或者变量使用完成后没有释放,这个对象一直占用着内存)，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。内存泄露会最终会导致内存溢出！当程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数，那就是内存溢出</li>
</ul>
<h5 id="6-NSArray-arrayWithobject-这个方法添加对象后，需要对这个数组做释放操作吗？"><a href="#6-NSArray-arrayWithobject-这个方法添加对象后，需要对这个数组做释放操作吗？" class="headerlink" title="6.[NSArray arrayWithobject:] 这个方法添加对象后，需要对这个数组做释放操作吗？"></a>6.[NSArray arrayWithobject:<id>] 这个方法添加对象后，需要对这个数组做释放操作吗？</id></h5><ul>
<li>不需要，这个对象被放到自动释放池中</li>
</ul>
<h5 id="7-自动释放池底层怎么实现"><a href="#7-自动释放池底层怎么实现" class="headerlink" title="7.自动释放池底层怎么实现"></a>7.自动释放池底层怎么实现</h5><ul>
<li>自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除,并且会给池子里面所有的对象都会做一次release操作.</li>
</ul>
<h5 id="8-自动释放池是什么-如何工作"><a href="#8-自动释放池是什么-如何工作" class="headerlink" title="8.自动释放池是什么,如何工作"></a>8.自动释放池是什么,如何工作</h5><ul>
<li>当您向一个对象发送一个autorelease消息时，Cocoa就会将该对象的一个引用放入到最新的自动释放池。它仍然是个正当的对象，因此自动释放池定义的作用域内的其它对象可以向它发送消息。当程序执行到作用域结束的位置时，自动释放池就会被释放，池中的所有对象也就被释放。</li>
<li>ojc-c是通过一种”referringcounting”(引用计数)的方式来管理内存的,对象在开始分配内存(alloc)的时候引用计数为一,以后每当碰到有copy,retain的时候引用计数都会加一,每当碰到release和autorelease的时候引用计数就会减一,如果此对象的计数变为了0,就会被系统销毁.<br>NSAutoreleasePool    就是用来做引用计数的管理工作的,这个东西一般不用你管的.</li>
<li>autorelease和release没什么区别,只是引用计数减一的时机不同而已，autorelease会在对象的使用真正结束的时候才做引用计数减一.</li>
</ul>
<h5 id="9-Objective-C-如何对内存管理的-说说你的看法和解决方法"><a href="#9-Objective-C-如何对内存管理的-说说你的看法和解决方法" class="headerlink" title="9.Objective-C 如何对内存管理的,说说你的看法和解决方法?"></a>9.Objective-C 如何对内存管理的,说说你的看法和解决方法?</h5><p>Objective-C 的内存管理主要有三种方式 ARC(自动内存计数)、手动内存计数、内存<br>池。    </p>
<ul>
<li>(Garbage Collection)自动内存计数：这种方式和 java 类似，在你的程序的执行过程中。始终有一个高人在背后准确地帮你收拾垃圾，你不用考虑它什么时候开始工作，怎样工作。你只需要明白，我申请了一段内存空间，当我不再使用从而这段内存成为垃圾的时候，我就彻底的把它忘记掉，反正那个高人会帮我收拾垃圾。遗憾的是，那个高人需要消耗一定的资源，在携带设备里面，资源是紧俏商品所以 iPhone 不支持这个功能。所以“Garbage Collection”不是本入门指南的范围，对“Garbage Collection”内部机制感兴趣的同学可以参考一些其他的资料，不过说老实话“Garbage Collection”不大适合适初学者研究。    解决: 通过 alloc– initial 方式创建的, 创建后引用计数+1, 此后每 retain 一次引用计数+1, 那么在程序中做相应次数的 release 就好了.</li>
<li>(Reference Counted)手动内存计数：就是说，从一段内存被申请之后，就存在一个变量用于保存这段内存被使用的次数，我们暂时把它称为计数器，当计数器变为 0 的时候，那么就是释放这段内存的时候。比如说，当在程序 A 里面段内存被成功申请完成之后，那么这个计数器就从 0 变成 1(我们把这个过程叫做 alloc)，然后程序 B 也需要使用这个内存，那么计数器就从 1 变成了 2(我们把这个过程叫做 retain)。紧接着程序 A 不再需要这段内存了，那么程序 A 就把这个计数器减 1(我们把这个过程叫做 release);程序 B 也不再需要这段内存的时候，那么也把计数器减 1(这个过程还是 release)。当系统(也就是 Foundation)发现这个计数器变成了 0，那么就会调用内存回收程序把这段内存回收(我们把这个过程叫做 dealloc)。<br>便提一句，如果没有 Foundation，那么维护计数器，释放内存等等工作需要你手工来完成。<br>决:一般是由类的静态方法创建的, 函数名中不会出现 alloc 或 init 字样, 如[NSString string]和[NSArray arrayWithObject:], 创建后引用计数+0, 在函数出栈后释放, 即相当于一个栈上的 局 部 变 量 .    当 然 也 可 以 通 过 retain 延 长 对 象 的 生 存 期 .<br> (NSAutoRealeasePool)内存池：可以通过创建和释放内存池控制内存申请和回收的时机.    解决:是由 autorelease 加入系统内存池, 内存池是可以嵌套的, 每个内存池都需要有一个创建释放对, 就像 main 函数中写的一样. 使用也很简单, 比如[[[NSString alloc]initialWithFormat:@”Hey you!”] autorelease], 即将一个NSString 对象加入到最内层的系统内存池, 当我们释放这个内存池时, 其中的对象都会被释放.</li>
</ul>
<h5 id="10-猜想-runloop内部是如何实现的？"><a href="#10-猜想-runloop内部是如何实现的？" class="headerlink" title="10.猜想 runloop内部是如何实现的？"></a>10.猜想 runloop内部是如何实现的？</h5><ul>
<li>从字面意思看：运行循环、跑圈；</li>
<li>本质：内部就是 do-while循环，在这个循环内部不断地处理各种事件(任务)，比如：Source、Timer、Observer；每条线程都有唯一一个 RunLoop 对象与之对应，主线程的 RunLoop 默认已经启动，子线程的 RunLoop 需要手动启动；每次 RunLoop 启动时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode，如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入，这样做主要是为了隔离不同 Mode 中的 Source、Timer、Observer，让其互不影响；</li>
</ul>
<h5 id="11-不手动指定-autoreleasepool的前提下，一个-autorealese对象在什么时刻释放？（比如在一个-vc的-viewDidLoad中创建）"><a href="#11-不手动指定-autoreleasepool的前提下，一个-autorealese对象在什么时刻释放？（比如在一个-vc的-viewDidLoad中创建）" class="headerlink" title="11.不手动指定 autoreleasepool的前提下，一个 autorealese对象在什么时刻释放？（比如在一个 vc的 viewDidLoad中创建）"></a>11.不手动指定 autoreleasepool的前提下，一个 autorealese对象在什么时刻释放？（比如在一个 vc的 viewDidLoad中创建）</h5><ul>
<li>分两种情况：手动干预释放时机、系统自动去释放<ul>
<li>手动干预释放时机：指定 autoreleasepool 就是所谓的：当前作用域大括号结束时就立即释放</li>
<li>系统自动去释放：不手动指定 autoreleasepool，Autorelease 对象会在当前的runloop 迭代结束时释放.</li>
</ul>
</li>
</ul>
<h4 id="Runtime方面（消息发送，NSHipster-对象关联，NSHipster-方法交换等等）"><a href="#Runtime方面（消息发送，NSHipster-对象关联，NSHipster-方法交换等等）" class="headerlink" title="Runtime方面（消息发送，NSHipster 对象关联，NSHipster 方法交换等等）"></a>Runtime方面（消息发送，NSHipster 对象关联，NSHipster 方法交换等等）</h4><h5 id="1-我们说的-oc是动态运行时语言是什么意思？"><a href="#1-我们说的-oc是动态运行时语言是什么意思？" class="headerlink" title="1.我们说的 oc是动态运行时语言是什么意思？"></a>1.我们说的 oc是动态运行时语言是什么意思？</h5><ul>
<li>多态。 主要是将数据类型的确定由编译时，推迟到了运行时。这个问题其实涉及到两个概念，运行时和多态。    简单来说，运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。    </li>
<li>多态：不同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat；那人类属于生物，猪也属于生物，都继承了 life 后，实现各自的 eat，但是调用是我们只需调用各自的 eat 方法。也就是不同的对象以自己的方式响应了相同的消息（响应了 eat 这个选择器）。因此也可以说，运行时机制是多态的基础</li>
</ul>
<h5 id="2-runtime实现的机制是什么-怎么用，一般用于干嘛-你还能记得你所使用的相关的头文件或者某些方法的名称吗？"><a href="#2-runtime实现的机制是什么-怎么用，一般用于干嘛-你还能记得你所使用的相关的头文件或者某些方法的名称吗？" class="headerlink" title="2.runtime实现的机制是什么,怎么用，一般用于干嘛. 你还能记得你所使用的相关的头文件或者某些方法的名称吗？"></a>2.runtime实现的机制是什么,怎么用，一般用于干嘛. 你还能记得你所使用的相关的头文件或者某些方法的名称吗？</h5><ul>
<li>运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量，动态改变类的方法实现，为类动态添加新的方法等需要导入 &lt; objc/message.h &gt; 、&lt; objc/runtime.h &gt;</li>
</ul>
<h5 id="3-Runtime-怎么添加属性、方法等"><a href="#3-Runtime-怎么添加属性、方法等" class="headerlink" title="3.Runtime 怎么添加属性、方法等"></a>3.Runtime 怎么添加属性、方法等</h5><ul>
<li>首先，创建一个类的分类，在分类中set 方法和get方法OC有两个运行时方法添加属性<ul>
<li>在set方法中调用objc setAssociatedObject(self, &amp;flashColorKey，flashColor ,OBJC_ASSOCIATION_RETAIN_NONATOMIC)获取属性</li>
<li>在get方法中调用objc getAssociatedObject(self, &amp;flashColorKey)</li>
</ul>
</li>
</ul>
<h5 id="4-Runtime-如何实现-weak-属性"><a href="#4-Runtime-如何实现-weak-属性" class="headerlink" title="4.Runtime 如何实现 weak 属性"></a>4.Runtime 如何实现 weak 属性</h5><ul>
<li>weak属性的特点：<br>weak 表明该属性定义了一种“非拥有关系” (nonowning relationship)。<br>为weak属性设置新值时，设置方法既不保留新值，也不释放旧值。<br>同assign类似，然而在属性所指的对象释放时候，属性值也会清空(nil out)。</li>
<li>runtime是如何实现 weak 变量的自动置nil？<br>weak 对象会放入一个 hash 表中。<br>用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc。<br>假如 weak 指向的对象内存地址是addr，那么就会以addr为键， 在这个 weak 表中搜索，找到所有以addr为键的 weak 对象，从而设置为 nil。</li>
<li>具体机制：<br>objc_storeWeak(&amp;weakPo, Model)函数：<br>objc_storeWeak函数把赋值对象（Model）的内存地址作为键值key，将weak修饰的属性变量（weakPo）的内存地址（&amp; weakPo）作为value，注册到 weak 表中。如果Model为0（nil），那么把变量（weakPo）的内存地址（&amp; weakPo）从weak表中删除，可以把objc_storeWeak(&amp;weakPo, Model)理解为：objc_storeWeak(value, key)，并且当key变nil，将value置nil。在Model非nil时，weakPo和Model指向同一个内存地址，在Model变nil时，weakPo变nil。此时向weakPo发送消息不会崩溃：在Objective-C中向nil发送消息是安全的。</li>
</ul>
<h5 id="5-简述下-Objective-C-中调用方法的过程（runtime）"><a href="#5-简述下-Objective-C-中调用方法的过程（runtime）" class="headerlink" title="5.简述下 Objective-C 中调用方法的过程（runtime）"></a>5.简述下 Objective-C 中调用方法的过程（runtime）</h5><ul>
<li>Objective-C是动态语言，每个方法在运行时会被动态转为消息发送，即：objc_msgSend(receiver, selector)，整个过程介绍如下：<ul>
<li>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类</li>
<li>然后在该类中的方法列表以及其父类方法列表中寻找方法运行</li>
<li>如果，在最顶层的父类（一般也就NSObject）中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent to XXX</li>
<li>但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会，这三次拯救程序奔溃的说明见问题《什么时候会报unrecognized selector的异常》中的说明</li>
</ul>
</li>
<li>补充说明：Runtime 铸就了Objective-C 是动态语言的特性，使得C语言具备了面向对象的特性，在程序运行期创建，检查，修改类、对象及其对应的方法，这些操作都可以使用runtime中的对应方法实现。</li>
</ul>
<h5 id="6-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"><a href="#6-runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）" class="headerlink" title="6.runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）"></a>6.runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）</h5><ul>
<li>每一个类对象中都一个对象方法列表（对象方法缓存）</li>
<li>类方法列表是存放在类对象中isa指针指向的元类对象中（类方法缓存）</li>
<li>方法列表中每个方法结构体中记录着方法的名称,方法实现,以及参数类型，其实selector本质就是方法名称,通过这个方法名称就可以在方法列表中找到对应的方法实现.</li>
<li>当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找</li>
<li>当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找</li>
</ul>
<h5 id="7-什么是method-swizzling（俗称黑魔法）"><a href="#7-什么是method-swizzling（俗称黑魔法）" class="headerlink" title="7.什么是method swizzling（俗称黑魔法）"></a>7.什么是method swizzling（俗称黑魔法）</h5><ul>
<li>简单说就是进行方法交换</li>
<li>在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的</li>
<li>每个类都有一个方法列表，存放着方法的名字和方法实现的映射关系，selector的本质其实就是方法名，IMP有点类似函数指针，指向具体的Method实现，通过selector就可以找到对应的IMP</li>
<li>交换方法的几种实现方式<ul>
<li>利用 method_exchangeImplementations 交换两个方法的实现</li>
<li>利用 class_replaceMethod 替换方法的实现</li>
<li>利用 method_setImplementation 来直接设置某个方法的IMP</li>
</ul>
</li>
</ul>
<h5 id="8-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"><a href="#8-能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？" class="headerlink" title="8.能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？"></a>8.能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</h5><ul>
<li>不能向编译后得到的类中增加实例变量；</li>
<li>能向运行时创建的类中添加实例变量；</li>
<li>分析如下：<ul>
<li>因为编译后的类已经注册在runtime中，类结构体中的objc_ivar_list 实例变量的链表和instance_size实例变量的内存大小已经确定，同时runtime 会调用class_setIvarLayout 或 class_setWeakIvarLayout来处理strong weak引用，所以不能向存在的类中添加实例变量</li>
<li>运行时创建的类是可以添加实例变量，调用 class_addIvar函数，但是得在调用objc_allocateClassPair之后，objc_registerClassPair之前，原因同上。</li>
</ul>
</li>
</ul>
<h5 id="9-objc-msgForward函数是做什么的？直接调用它将会发生什么？"><a href="#9-objc-msgForward函数是做什么的？直接调用它将会发生什么？" class="headerlink" title="9._objc_msgForward函数是做什么的？直接调用它将会发生什么？"></a>9._objc_msgForward函数是做什么的？直接调用它将会发生什么？</h5><ul>
<li>_objc_msgForward是IMP类型，用于消息转发的：当向一个对象发送一条消息，但它并没有实现的时候，_objc_msgForward会尝试做消息转发</li>
<li>直接调用_objc_msgForward是非常危险的事，这是把双刃刀，如果用不好会直接导致程序Crash，但是如果用得好，能做很多非常酷的事</li>
<li>JSPatch就是直接调用_objc_msgForward来实现其核心功能的</li>
</ul>
<h5 id="10-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？"><a href="#10-使用runtime-Associate方法关联的对象，需要在主对象dealloc的时候释放么？" class="headerlink" title="10.使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？"></a>10.使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？</h5><p>无论在MRC下还是ARC下均不需要被关联的对象在生命周期内要比对象本身释放的晚很多，它们会在被 NSObject -dealloc 调用的object_dispose()方法中释放<br>补充：对象的内存销毁时间表，分四个步骤</p>
<p>（1）调用 -release ：引用计数变为零</p>
<ul>
<li>对象正在被销毁，生命周期即将结束. </li>
<li>不能再有新的 __weak 弱引用，否则将指向 nil.</li>
<li>调用 [self dealloc]</li>
</ul>
<p>（2）父类调用 -dealloc </p>
<ul>
<li>继承关系中最直接继承的父类再调用 -dealloc </li>
<li>如果是 MRC 代码 则会手动释放实例变量们（iVars）</li>
<li>继承关系中每一层的父类 都再调用 -dealloc</li>
</ul>
<p>（3）NSObject 调 -dealloc </p>
<ul>
<li>只做一件事：调用 Objective-C runtime 中object_dispose() 方法</li>
</ul>
<p>（4） 调用 object_dispose()</p>
<ul>
<li>为 C++ 的实例变量们（iVars）调用 destructors</li>
<li>为 ARC 状态下的 实例变量们（iVars） 调用 -release </li>
<li>解除所有使用 runtime Associate方法关联的对象 </li>
<li>解除所有 __weak 引用 </li>
<li>调用 free()</li>
</ul>
<h4 id="KVO内部实现原理（多家公司有问到）"><a href="#KVO内部实现原理（多家公司有问到）" class="headerlink" title="KVO内部实现原理（多家公司有问到）"></a>KVO内部实现原理（多家公司有问到）</h4><h5 id="1-KVO内部实现原理"><a href="#1-KVO内部实现原理" class="headerlink" title="1.KVO内部实现原理"></a>1.KVO内部实现原理</h5><ul>
<li>KVO 是基于 runtime 机制实现的</li>
<li>当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一<br>个派生类，在这个派生类中重写基类中任何被观察属性的 setter 方法。派生类在被重写的 setter 方法内实现真正的通知机制</li>
<li>如果原类为 Person，那么生成的派生类名为 NSKVONotifying_Person</li>
<li>每个类对象中都有一个 isa 指针指向当前类，当一个类对象的第一次被观察，那么<br>系统会偷偷将 isa 指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的 setter 方法</li>
<li>键值观察通知依赖于 NSObject的两方法 : willChangeValueForKey:和didChangevlueForKey:；在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey: 会被调用，继而 observeValueForKey:ofObject:change:context: 也会被调用。</li>
<li>补充：KVO 的这套实现机制中苹果还偷偷重写了 class 方法，让我们误认为还是使<br>用的当前类，从而达到隐藏生成的派生类</li>
</ul>
<h5 id="2-KVC和-KVO的-keyPath一定是属性么？"><a href="#2-KVC和-KVO的-keyPath一定是属性么？" class="headerlink" title="2.KVC和 KVO的 keyPath一定是属性么？"></a>2.KVC和 KVO的 keyPath一定是属性么？</h5><ul>
<li>可以是成员变量</li>
</ul>
<h4 id="Runloop方面（深入理解RunLoop）"><a href="#Runloop方面（深入理解RunLoop）" class="headerlink" title="Runloop方面（深入理解RunLoop）"></a>Runloop方面（深入理解RunLoop）</h4><h5 id="1-NSRunLoop-的实现机制-及在多线程中如何使用"><a href="#1-NSRunLoop-的实现机制-及在多线程中如何使用" class="headerlink" title="1.NSRunLoop 的实现机制,及在多线程中如何使用"></a>1.NSRunLoop 的实现机制,及在多线程中如何使用</h5><ul>
<li>NSRunLoop是IOS消息机制的处理模式<ul>
<li>NSRunLoop的主要作用：控制NSRunLoop里面线程的执行和休眠，在有事情做的时候使当前NSRunLoop控制的线程工作，没有事情做让当前NSRunLoop的控制的线程休眠。</li>
<li>NSRunLoop 就是一直在循环检测，从线程start到线程end，检测inputsource(如点击，双击等操作)异步事件，检测timesource同步事件，检测到输入源会执行处理函数，首先会产生通知，corefunction向线程添加runloop observers来监听事件，意在监听事件发生时来做处理。</li>
<li>runloopmode是一个集合，包括监听：事件源，定时器，以及需通知的runloop observers</li>
</ul>
</li>
<li>只有在为你的程序创建次线程的时候，才需要运行runloop。对于程序的主线程而言，runloop是关键部分。Cocoa提供了运行主线程runloop的代码同时也会自动运行runloop。IOS程序UIApplication中的run方法在程序正常启动的时候就会启动runloop。如果你使用xcode提供的模板创建的程序，那你永远不需要自己去启动runloop;在多线程中，你需要判断是否需要runloop。如果需要runloop，那么你要负责配置runloop并启动。你不需要在任何情况下都去启动runloop。比如，你使用线程去处理一个预先定义好的耗时极长的任务时你就可以毋需启动runloop。Runloop只在你要和线程有交互时才需要</li>
</ul>
<h5 id="2-runloop-定时源和输入源"><a href="#2-runloop-定时源和输入源" class="headerlink" title="2.runloop 定时源和输入源"></a>2.runloop 定时源和输入源</h5><ul>
<li>你创建的程序不需要显示的创建runloop；每个线程，包括程序的主线程（main thread）都有与之相应的runloop对象,主线程会自行创建并运行runloop</li>
<li>Run loop处理的输入事件有两种不同的来源：输入源（input source）和定时源（timer source）</li>
<li>输入源传递异步消息，通常来自于其他线程或者程序。定时源则传递同步消息，在特定时间或者一定的时间间隔发生</li>
</ul>
<h5 id="3-runloop-和线程有什么关系"><a href="#3-runloop-和线程有什么关系" class="headerlink" title="3.runloop 和线程有什么关系"></a>3.runloop 和线程有什么关系</h5><ul>
<li>每条线程都有唯一的一个 RunLoop 对象与之对应的</li>
<li>主线程的 RunLoop 是自动创建并启动子线程的 RunLoop 需要手动创建</li>
<li>子线程的 RunLoop 创建步骤如下：<ul>
<li>在子线程中调用[NSRunLoop currentRunLoop]创建 RunLoop 对象（懒加载，只创建<br>一次）</li>
<li>获得 RunLoop 对象后要调用 run方法来启动一个运行循环<code>[[NSRunLoop currentRunLoop] run]</code>;</li>
</ul>
</li>
</ul>
<h5 id="4-runloop-的-mode-作用是什么"><a href="#4-runloop-的-mode-作用是什么" class="headerlink" title="4.runloop 的 mode 作用是什么"></a>4.runloop 的 mode 作用是什么</h5><ul>
<li>用来控制一些特殊操作只能在指定模式下运行，一般可以通过指定操作的运行mode来控制执行时机，以提高用户体验</li>
<li>系统默认注册了 5 个 Mode</li>
<li>kCFRunLoopDefaultMode：App 的默认 Mode，通常主线程是在这个 Mode下运行，对应OC中的：NSDefaultRunLoopMode</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>kCFRunLoopCommonModes:这是一个标记 Mode，不是一种真正的 Mode，事件可以运行在所有标有 common modes 标记的模式中,对 应 OC 中 的NSRunLoopCommonModes<br>带有common    modes标 记 的 模 式 有 ：UITrackingRunLoopMode 和 kCFRunLoopDefaultMode<ul>
<li>UIInitializationRunLoopMode：在启动 App 时进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode：接受系统事件的内部 Mode，通常用不到</li>
</ul>
</li>
</ul>
<h5 id="6-猜想-runloop-内部是如何实现的？"><a href="#6-猜想-runloop-内部是如何实现的？" class="headerlink" title="6.猜想 runloop 内部是如何实现的？"></a>6.猜想 runloop 内部是如何实现的？</h5><ul>
<li>从字面意思看：运行循环、跑圈；</li>
<li>本质：内部就是 do-while循环，在这个循环内部不断地处理各种事件(任务)，比如：Source、Timer、Observer；</li>
<li>每条线程都有唯一一个 RunLoop 对象与之对应，主线程的 RunLoop 默认已经启动</li>
<li>子线程的 RunLoop 需要手动启动</li>
<li>每次 RunLoop 启动时，只能指定其中一个 Mode，这个 Mode 被称作 CurrentMode，如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入，这样做主要是为了隔离不同 Mode 中的 Source、Timer、Observer，让其互不影响；</li>
</ul>
<h4 id="多线程方面（GCD、NSOperation居多）（关于iOS多线程，你看我就够了）"><a href="#多线程方面（GCD、NSOperation居多）（关于iOS多线程，你看我就够了）" class="headerlink" title="多线程方面（GCD、NSOperation居多）（关于iOS多线程，你看我就够了）"></a>多线程方面（GCD、NSOperation居多）（关于iOS多线程，你看我就够了）</h4><h5 id="1-多线程的底层实现"><a href="#1-多线程的底层实现" class="headerlink" title="1.多线程的底层实现"></a>1.多线程的底层实现</h5><ul>
<li>首先搞清楚什么是线程、什么是多线程</li>
<li>Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制是基于Mach的线程</li>
<li>开发中很少用Mach级的线程，因为Mach级的线程没有提供多线程的基本特征，线程之间是独立的</li>
<li>开发中实现多线程的方案<br>· C语言的POSIX接口：#include &lt;pthread.h&gt;<br>· OC的NSThread<br>· C语言的GCD接口（性能最好，代码更精简）<br>· OC的NSOperation和NSOperationQueue（基于GCD）</li>
</ul>
<h5 id="2-线程间怎么通信？"><a href="#2-线程间怎么通信？" class="headerlink" title="2.线程间怎么通信？"></a>2.线程间怎么通信？</h5><ul>
<li>线程间通信：在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信</li>
<li>线程间通信的体现<ul>
<li>1个线程传递数据给另1个线程</li>
<li>在1个线程中执行完特定任务后，转到另1个线程继续执行任务</li>
</ul>
</li>
</ul>
<h5 id="3-列举-cocoa-中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？"><a href="#3-列举-cocoa-中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？" class="headerlink" title="3.列举 cocoa 中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？"></a>3.列举 cocoa 中常见对几种多线程的实现，并谈谈多线程安全的几种解决办法及多线程安全怎么控制？</h5><ul>
<li>只在主线程刷新访问UI</li>
<li>如果要防止资源抢夺，得用synchronized进行加锁保护</li>
<li>如果异步操作要保证线程安全等问题, 尽量使用GCD(有些函数默认就是安全的)</li>
</ul>
<h5 id="4-GCD-内部怎么实现的"><a href="#4-GCD-内部怎么实现的" class="headerlink" title="4.GCD 内部怎么实现的"></a>4.GCD 内部怎么实现的</h5><ul>
<li>iOS和OS X的核心是XNU内核，GCD是基于XNU内核实现的</li>
<li>GCD的API全部在libdispatch库中</li>
<li>GCD的底层实现主要有Dispatch Queue和Dispatch Source<br>· Dispatch Queue ：管理block(操作)<br>· Dispatch Source ：处理事件</li>
</ul>
<h5 id="5-你用过-NSOperationQueue-么？如果用过或者了解的话，你为什么要使用"><a href="#5-你用过-NSOperationQueue-么？如果用过或者了解的话，你为什么要使用" class="headerlink" title="5.你用过 NSOperationQueue 么？如果用过或者了解的话，你为什么要使用"></a>5.你用过 NSOperationQueue 么？如果用过或者了解的话，你为什么要使用</h5><p>NSOperationQueue，实现了什么？请描述它和 GCD 的区别和类似的地方（提<br>示：可以从两者的实现机制和适用范围来描述）</p>
<ul>
<li>GCD是纯C语言的API，NSOperationQueue是基于GCD的OC版本封装</li>
<li>GCD只支持FIFO的队列，NSOperationQueue可以很方便地调整执行顺序、设置最大并发数量</li>
<li>NSOperationQueue可以在轻松在Operation间设置依赖关系，而GCD需要写很多的代码才能实现</li>
<li>NSOperationQueue支持KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld）</li>
<li>GCD的执行速度比NSOperationQueue快<ul>
<li>任务之间不太互相依赖：GCD</li>
<li>任务之间有依赖\或者要监听任务的执行情况：NSOperationQueue</li>
</ul>
</li>
</ul>
<h5 id="6-既然提到-GCD，那么问一下在使用-GCD-以及-block-时要注意些什么？它们两是一回事儿么？block-在-ARC-中和传统的-MRC-中的行为和用法有没有什么区别，需要注意些什么？"><a href="#6-既然提到-GCD，那么问一下在使用-GCD-以及-block-时要注意些什么？它们两是一回事儿么？block-在-ARC-中和传统的-MRC-中的行为和用法有没有什么区别，需要注意些什么？" class="headerlink" title="6.既然提到 GCD，那么问一下在使用 GCD 以及 block 时要注意些什么？它们两是一回事儿么？block 在 ARC 中和传统的 MRC 中的行为和用法有没有什么区别，需要注意些什么？"></a>6.既然提到 GCD，那么问一下在使用 GCD 以及 block 时要注意些什么？它们两是一回事儿么？block 在 ARC 中和传统的 MRC 中的行为和用法有没有什么区别，需要注意些什么？</h5><ul>
<li>Block的使用注意：<ul>
<li>block的内存管理</li>
<li>防止循环retian<br>· 非ARC（MRC）：<strong>block<br>· ARC：</strong>weak__unsafe_unretained</li>
</ul>
</li>
</ul>
<h5 id="7-什么是-TCP-连接的三次握手"><a href="#7-什么是-TCP-连接的三次握手" class="headerlink" title="7.什么是 TCP 连接的三次握手"></a>7.什么是 TCP 连接的三次握手</h5><ul>
<li>第一次握手：客户端发送 syn 包(syn=j)到服务器，并进入 SYN_SEND 状态，等待服务器确认；</li>
<li>第二次握手：服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</li>
<li>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。<br>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。理想状态下，TCP 连接一旦建立，在通信双方中的任何一方主动关闭连接之前，TCP    连接都将被一直保持下去。断开连接时服务器和客户端均可以主动发起断开 TCP 连接的请求，断开过程需要经过“四次握手”（过程就不细写了，就是服务器和客户端交互，最终确定断开）</li>
</ul>
<h5 id="8-在项目什么时候选择使用-GCD，什么时候选择-NSOperation"><a href="#8-在项目什么时候选择使用-GCD，什么时候选择-NSOperation" class="headerlink" title="8.在项目什么时候选择使用 GCD，什么时候选择 NSOperation?"></a>8.在项目什么时候选择使用 GCD，什么时候选择 NSOperation?</h5><ul>
<li>项目中使用 NSOperation 的优点是 NSOperation 是对线程的高度抽象，在项目中使用它，会使项目的程序结构更好，子类化 NSOperation 的设计思路，是具有面向对象的优点(复用、封装)，使得实现是多线程支持，而接口简单，建议在复杂项目中使用。项目中使用 GCD 的优点是 GCD 本身非常简单、易用，对于不复杂的多线程操作，会节省代码量，而 Block 参数的使用，会是代码更为易读，建议在简单项目中使用。</li>
</ul>
<h4 id="SDWebImage源码分析"><a href="#SDWebImage源码分析" class="headerlink" title="SDWebImage源码分析"></a>SDWebImage源码分析</h4><h5 id="1-SDWebImage-内部实现过程"><a href="#1-SDWebImage-内部实现过程" class="headerlink" title="1.SDWebImage 内部实现过程"></a>1.SDWebImage 内部实现过程</h5><ul>
<li>入口<code>setImageWithURL:placeholderImage:options:</code>会先<code>placeholderImage</code>显<br>示，然后<code>SDWebImageManager</code>根据URL开始处理图片。进入<code>SDWebImageManager-downloadWithURL:delegate:options:userInfo:</code>，交给<code>SDImageCache</code>从缓存查找图片是否已经下载<code>queryDiskCacheForKey:delegate:userInfo:</code>.先从内存图片缓存查找是否有图片，如果内存中已经有图片缓存，<code>SDImageCacheDelegate</code>回调<code>imageCache:didFindImage:forKey:userInfo:</code>到<code>SDWebImageManager。SDWebImageManagerDelegate</code>回调<code>webImageManager:didFinishWithImage:</code>到<code>UIImageView+WebCache</code>等前端展示图片。如果内存缓存中没有，生成<code>NSInvocationOperation</code>添加到队列开始从硬盘查找图片是否已经缓存。根据<code>URLKey</code>在硬盘缓存目录下尝试读取图片文件。这一步是在<code>NSOperation</code>进行的操作，所以回主线程进行结果回调<code>notifyDelegate:</code>。如果上一操作从硬盘读取到了图片，将图片添加到内存缓存中（如果空闲内存过小，会先清空内存缓存）。<code>SDImageCacheDelegate</code>回调<code>imageCache:didFindImage:forKey:userInfo:</code>。进而回调展示图片。如果从硬盘缓存目录读取不到图片，说明所有缓存都不存在该图片，需要下载图片，回调<code>imageCache:didNotFindImageForKey:userInfo:</code>。共享或重新生成一个下载器<code>SDWebImageDownloader</code>开始下载图片。图片下载由<code>NSURLConnection</code>来做，实现相关<code>delegate</code>来判断图片下载中、下载完成和下载失败。<code>connection:didReceiveData:</code>中利用ImageIO做了按图片下载进度加载效果。<code>connectionDidFinishLoading:</code>数据下载完成后交给SDWebImageDecoder做图片解码处理。图片解码处理在一个<code>NSOperationQueue</code>完成，不会拖慢主线程UI。如果有需要对下载的图片进行二次处理，最好也在这里完成，效率会好很多。</li>
</ul>
<h4 id="block相关"><a href="#block相关" class="headerlink" title="block相关"></a>block相关</h4><h5 id="1-Block-内部的实现原理"><a href="#1-Block-内部的实现原理" class="headerlink" title="1.Block 内部的实现原理"></a>1.Block 内部的实现原理</h5><ul>
<li>Objective-C是对C语言的扩展，block的实现是基于指针和函数指针</li>
</ul>
<h5 id="2-block-和-weak-修饰符的区别"><a href="#2-block-和-weak-修饰符的区别" class="headerlink" title="2.block 和 weak 修饰符的区别"></a>2.block 和 weak 修饰符的区别</h5><ul>
<li>__block 不管是 ARC 还是 MRC 模式下都可以使用，可以修饰对象，也可以修饰基<br>本数据类型</li>
<li>__weak 只能在 ARC 模式下使用，只能修饰对象（NSString），不能修饰基本数据<br>类型</li>
<li>block 修饰的对象可以在中被重新赋值，weak 修饰的对象不可以</li>
</ul>
<h5 id="3-使用-block-时什么情况会发生引用循环，如何解决"><a href="#3-使用-block-时什么情况会发生引用循环，如何解决" class="headerlink" title="3.使用 block 时什么情况会发生引用循环，如何解决"></a>3.使用 block 时什么情况会发生引用循环，如何解决</h5><ul>
<li>发生情况<ul>
<li>一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。<br>解决方法是将该对象使用<strong>weak或者</strong>block修饰符修饰之后再在block中使用。</li>
</ul>
</li>
<li>解决办法<ul>
<li>id <strong>weak weakSelf = self; 或者 </strong>weak __typeof(self)weakSelf = self;. 该方法可以设置宏</li>
<li>id __block weakSelf = self;或者将其中一方强制制空 xxx = nil。</li>
</ul>
</li>
</ul>
<h5 id="4-在-block-内如何修改-block-外部变量"><a href="#4-在-block-内如何修改-block-外部变量" class="headerlink" title="4.在 block 内如何修改 block 外部变量"></a>4.在 block 内如何修改 block 外部变量</h5><ul>
<li>第一种是可以修改 static 全局变量；</li>
<li>第二种是可以修改用新关键字 __block 修饰的变量</li>
</ul>
<h4 id="其他可能的面试点"><a href="#其他可能的面试点" class="headerlink" title="其他可能的面试点"></a>其他可能的面试点</h4><h5 id="1-tableView的优化"><a href="#1-tableView的优化" class="headerlink" title="1.tableView的优化"></a>1.tableView的优化</h5><ul>
<li>赋值和计算布局分离<ul>
<li>autolayout进行布局好处是不需要开发者自己计算约束，缺点是每次显示cell都会重新计算cell的尺寸来设置约束，不会对计算过一次的尺寸进行缓存</li>
<li>开发者可以手动计算布局（设置frame）来获取cell的高度，然后根据indexPath设置内存缓存，这样就比autolayout性能更好</li>
</ul>
</li>
<li>自定义Cell的绘制<ul>
<li>如果cell中没有多余的响应时间，可以使用CALayer或者CoreGraphics（使用GPU处理）来进行视图的绘制，因为CALayer和CoreGraphics绘制比创建UIView（使用CPU处理）性能要高很多</li>
<li>fackebook出了一个类库，可以对视图进行绘制，名称叫AsyncDispiayKit</li>
</ul>
</li>
<li>滑动UITableView时，需要加载对应的内容<ul>
<li>现在在第1行，一滚动，滚动目标行是第11行，但是界面里最多显示3行，从用户角度来讲，他不需要看2 ~ 10行的内容，所以可以基于此，不去加载2 ~10行的图片</li>
</ul>
</li>
<li>其他处理<ul>
<li>正确使用reuseldentifier来这里用Cells</li>
<li>尽量使所有的viiew不透明，包括Cell自身（如果视图时半透明，则需要进行渲染，渲染耗费性能比较多）</li>
<li>尽力少用或者不用透明图层</li>
<li>如果使用Cell内显示的内容来来自Web，使用异步加载，缓存请求结果（SDWebimage&amp;AFN进行异步加载）</li>
<li>减少subviews的数量</li>
<li>在hieghtForRowAthIndexpath：中尽量不要使用cellForRowAtlndexPath;如果你需要用到它，只用一次然后缓存结果</li>
<li>尽量少用addView给Cell动态添加View，可以初始化时就添加，然后通过hide来控制是否显示（尽量别每次调用cellForRow的时候动态加载，尽量在创建时创建一次）</li>
<li>如果使用dequeueReusableCellWithIdentifier:(NSString <em>)identifier forIndexPath:(NSIndexPath </em>)indexPath方法则要么在IB中注册了cell要么就需要代码注册，该方法会自动创建cell</li>
<li>如果使用dequeueReusableCellWithIdentifier:(NSString *)identifier方法，就需要手动判断cell是否为空，进行手动创建</li>
</ul>
</li>
</ul>
<h5 id="2-地图定位"><a href="#2-地图定位" class="headerlink" title="2.地图定位"></a>2.地图定位</h5><ul>
<li>高德地图  3D地图  正北方向不会隐藏指南针</li>
<li>苹果原生地图<ul>
<li>正北方会自动隐藏指南针</li>
</ul>
</li>
<li>绘制运动轨迹<ul>
<li>绘制折线 ： 查阅高德SDK的官方文档 ，因为他们的类前缀不同，其他都相同</li>
<li>判断overlayer的类型   设置显示属性的线宽和颜色</li>
</ul>
</li>
<li>自定义轨迹算法（利用速度数值进行轨迹优化）<ul>
<li>位置保持不变，速度 == 0</li>
<li>GPS信号不好，速度可能会为负值</li>
<li>速度 要小于或者等于0<ul>
<li>不判断会不停的创建轨迹线条模型，销毁性能</li>
<li>如果只是在室内不会绘制任何轨迹<ul>
<li>自定义轨迹优化算法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>利用时间戳优化轨迹性能<ul>
<li>判断定位的时间差值，暂时顶一个时间差值因子，如果超出了这个时间差值，就认为定位的精度不够，避免了室内出现杂线</li>
</ul>
</li>
<li>根据运动速度，调整运动轨迹颜色<ul>
<li>定义计算性属性</li>
<li>根据不同运动类型，返回不同的比例因子</li>
<li>具体的比例因子应该实际测试获得</li>
</ul>
</li>
<li>如果点击暂停按钮之后，我们不想让地图画线，应该怎么做<ul>
<li>在运动状态改变的时候，如果不是继续的状态，就清空起始位置</li>
</ul>
</li>
<li>运动类软件为什么不用解决跳秒的问题<ul>
<li>出现跳秒的原因：前后两次定位点之间的时间差值超过1s- </li>
<li>用户体验：用户不会盯着屏幕看</li>
<li>降低能耗：如果增加一个时钟，会增加额外的性能消耗</li>
</ul>
</li>
<li>GPS信号，我们确认了几种状态<ul>
<li>断开连接，差，正常，良好</li>
<li>判断室内一定不要用speed &lt; = 0</li>
<li>速度speed &lt; 0 对应GPS信号不好</li>
<li>速度speed == 意味着用户位置没有移动</li>
</ul>
</li>
<li>定位点时间差值越接近1，信号越好</li>
<li>室外／室外的GPS信号有什么特点？<ul>
<li>室内 speed == -1</li>
<li>室外时间差值大多小于0.01秒</li>
<li>室外到室内，信号变化迟钝（所有地图框架都是如此，取决于定位的实现机制</li>
</ul>
</li>
<li>语音播报<ul>
<li>语音合成机械，用户体验不好</li>
<li>录制一些效果好的mp3素材文件，使用AVPlayer播放</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/04/面试题总结/" data-id="cjfni46ww00059fdl7tjmuwh0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GIT常用的命令" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/03/GIT常用的命令/" class="article-date">
  <time datetime="2018-04-02T18:28:16.000Z" itemprop="datePublished">2018-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/03/GIT常用的命令/">GIT常用的命令</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="使用Git命令，需要记住以下几个专用名词以及其译名"><a href="#使用Git命令，需要记住以下几个专用名词以及其译名" class="headerlink" title="使用Git命令，需要记住以下几个专用名词以及其译名"></a>使用Git命令，需要记住以下几个专用名词以及其译名</h1><hr>
<blockquote>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
</blockquote>
<hr>
<h1 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在当前目录新建一个Git代码库</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line"># 新建一个目录，将其初始化为Git代码库</span><br><span class="line">$ git init [project-name]</span><br><span class="line"></span><br><span class="line"># 下载一个项目和它的整个代码历史</span><br><span class="line">$ git clone [url]</span><br></pre></td></tr></table></figure>
<h1 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h1><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 显示当前的Git配置</span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"># 编辑Git配置文件</span><br><span class="line">$ git config -e [--global]</span><br><span class="line"></span><br><span class="line"># 设置提交代码时的用户信息</span><br><span class="line">$ git config [--global] user.name &quot;[name]&quot;</span><br><span class="line">$ git config [--global] user.email &quot;[email address]&quot;</span><br></pre></td></tr></table></figure>
<h1 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加\删除文件"></a>三、增加\删除文件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>
<h1 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>
<h1 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有本地分支</span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"># 列出所有远程分支</span><br><span class="line">$ git branch -r</span><br><span class="line"></span><br><span class="line"># 列出所有本地分支和远程分支</span><br><span class="line">$ git branch -a</span><br><span class="line"></span><br><span class="line"># 新建一个分支，但依然停留在当前分支</span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，并切换到该分支</span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向指定commit</span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个分支，与指定的远程分支建立追踪关系</span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 切换到指定分支，并更新工作区</span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"></span><br><span class="line"># 切换到上一个分支</span><br><span class="line">$ git checkout -</span><br><span class="line"></span><br><span class="line"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"># 合并指定分支到当前分支</span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"># 选择一个commit，合并进当前分支</span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"># 删除分支</span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"></span><br><span class="line"># 删除远程分支</span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure>
<h1 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>
<h1 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"># 显示有变更的文件</span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"># 显示当前分支的版本历史</span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"># 显示commit历史，以及每次commit发生变更的文件</span><br><span class="line">$ git log --stat</span><br><span class="line"></span><br><span class="line"># 搜索提交历史，根据关键词</span><br><span class="line">$ git log -S [keyword]</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，每个commit占据一行</span><br><span class="line">$ git log [tag] HEAD --pretty=format:%s</span><br><span class="line"></span><br><span class="line"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br><span class="line">$ git log [tag] HEAD --grep feature</span><br><span class="line"></span><br><span class="line"># 显示某个文件的版本历史，包括文件改名</span><br><span class="line">$ git log --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"></span><br><span class="line"># 显示指定文件相关的每一次diff</span><br><span class="line">$ git log -p [file]</span><br><span class="line"></span><br><span class="line"># 显示过去5次提交</span><br><span class="line">$ git log -5 --pretty --oneline</span><br><span class="line"></span><br><span class="line"># 显示所有提交过的用户，按提交次数排序</span><br><span class="line">$ git shortlog -sn</span><br><span class="line"></span><br><span class="line"># 显示指定文件是什么人在什么时间修改过</span><br><span class="line">$ git blame [file]</span><br><span class="line"></span><br><span class="line"># 显示暂存区和工作区的差异</span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"># 显示暂存区和上一个commit的差异</span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"></span><br><span class="line"># 显示工作区与当前分支最新commit之间的差异</span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"># 显示两次提交之间的差异</span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"></span><br><span class="line"># 显示今天你写了多少行代码</span><br><span class="line">$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 显示某次提交的元数据和内容变化</span><br><span class="line">$ git show [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交发生变化的文件</span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"></span><br><span class="line"># 显示某次提交时，某个文件的内容</span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"></span><br><span class="line"># 显示当前分支的最近几次提交</span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>
<h1 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>
<h1 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>
<h1 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/03/GIT常用的命令/" data-id="cjfni46ws00029fdlu6ppftzi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-念十八" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/01/念十八/" class="article-date">
  <time datetime="2018-03-31T19:54:40.000Z" itemprop="datePublished">2018-04-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/01/念十八/">念十八</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="也曾年少也曾狂"><a href="#也曾年少也曾狂" class="headerlink" title="也曾年少也曾狂"></a>也曾年少也曾狂</h2><h2 id="嬉笑痴情费周章"><a href="#嬉笑痴情费周章" class="headerlink" title="嬉笑痴情费周章"></a>嬉笑痴情费周章</h2><h2 id="命恨相思催人老"><a href="#命恨相思催人老" class="headerlink" title="命恨相思催人老"></a>命恨相思催人老</h2><h2 id="一夜青丝雪茫茫"><a href="#一夜青丝雪茫茫" class="headerlink" title="一夜青丝雪茫茫"></a>一夜青丝雪茫茫</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/01/念十八/" data-id="cjfni46wt00039fdlgxw2njx8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/06/Python3基本语法/">Python3基本语法</a>
          </li>
        
          <li>
            <a href="/2018/04/04/移动硬盘修复/">移动硬盘修复</a>
          </li>
        
          <li>
            <a href="/2018/04/04/iOS中pch文件的设置/">iOS中pch文件的设置</a>
          </li>
        
          <li>
            <a href="/2018/04/04/面试题总结/">面试题总结</a>
          </li>
        
          <li>
            <a href="/2018/04/03/GIT常用的命令/">GIT常用的命令</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>