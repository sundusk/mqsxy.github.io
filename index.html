<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>sundusk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="sundusk">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="sundusk">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="sundusk">
  
    <link rel="alternate" href="/atom.xml" title="sundusk" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">sundusk</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="swift-Swift4.0数组（阵列）学习" class="article article-type-swift" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/Swift4.0数组（阵列）学习/" class="article-date">
  <time datetime="2018-05-14T06:15:07.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/Swift4.0数组（阵列）学习/">4.0数组（阵列）学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义数组常量（常量只有读操作）"><a href="#定义数组常量（常量只有读操作）" class="headerlink" title="定义数组常量（常量只有读操作）"></a>定义数组常量（常量只有读操作）</h4><p>让array1：[Int] = [11，55，5]让array2 = [11,55,5]</p>
<h4 id="定义数组变量"><a href="#定义数组变量" class="headerlink" title="定义数组变量"></a>定义数组变量</h4><p>var array：[Int] = [] //这是我最喜欢的var array0：[Int] = [10，20，30] //初始化并赋值var array1：[Int] = Array（）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var array2 = Array&lt;Int&gt;()</span><br><span class="line">var array3 = [Int]()</span><br><span class="line">var array4 = Array(repeating: 0, count: 8) // 初始化一个定长数组,用0填充</span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>array = [5，55，555]</p>
<h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>let value = array [2] //第几个元素</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>array.remove（at：1）//通过下标删除array.removeAll（）//删除所有元素array.removeLast（）//删除最后一个元素array.removeFirst（）//删除第一个元素</p>
<h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>array.append（10）</p>
<h4 id="元素重新赋值"><a href="#元素重新赋值" class="headerlink" title="元素重新赋值"></a>元素重新赋值</h4><p>数组[1] = 66</p>
<h4 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">array.forEach &#123; item in</span><br><span class="line"></span><br><span class="line">     print(item)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for item in array &#123;</span><br><span class="line"></span><br><span class="line">     print(item)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for (index, value) in array.enumerated() &#123;</span><br><span class="line"></span><br><span class="line">     print(&quot;\(index) --&amp;gt; \(value)&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> for index in 0..&amp;lt;array.count &#123;</span><br><span class="line"></span><br><span class="line">     print(array[index])</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/Swift4.0数组（阵列）学习/" data-id="cjh5uw3hy00089mxmryhu1aka" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="swift-Swift4.0字典（Dictionary）学习" class="article article-type-swift" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/Swift4.0字典（Dictionary）学习/" class="article-date">
  <time datetime="2018-05-14T06:14:51.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/Swift4.0字典（Dictionary）学习/">4.0字典（Dictionary）学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义字典常量（常量只有读操作）"><a href="#定义字典常量（常量只有读操作）" class="headerlink" title="定义字典常量（常量只有读操作）"></a>定义字典常量（常量只有读操作）</h4><p>让dictionary1 = [“key1”：888，“key2”：999] let dictionary2：[String：Int] = [“key1”：888，“key2”：999]</p>
<h4 id="定义字典变量"><a href="#定义字典变量" class="headerlink" title="定义字典变量"></a>定义字典变量</h4><p>var dictionary：[String：Int] = [：] var dictionary1 = [“key1”：55，“key2”：555] var dictionary2 = Dictionary（）</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><p>dictionary = [“key1”：88，“key2”：888，“key3”：8888]</p>
<h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><p>let value = dictionary [“key1”] //取某个值let values = dictionary.values.sorted（）//获取所有值，从小到大排序let keys = dictionary.keys.sorted（）//获取所有密钥，从小到大排序</p>
<h4 id="修改值-添加元素"><a href="#修改值-添加元素" class="headerlink" title="修改值/添加元素"></a>修改值/添加元素</h4><p>dictionary.updateValue（8，forKey：“key4”）//如果key不存在，则添加新元素dictionary.updateValue（99，forKey：“key1”）//如果key存在，则修改value</p>
<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>dictionary.removeAll（）//删除所有元素dictionary.removeValue（forKey：“key1”）//通过查找键来删除元素</p>
<p>let index = dictionary.index（dictionary.startIndex，offsetBy：1）dictionary.remove（at：index）//通过下标删除元素，offsetBy是第几个元素</p>
<h4 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">for item in dictionary &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;\(item.key) --&amp;gt; \(item.value)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (key, value) in dictionary &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;\(key) --&amp;gt; \(value)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for sequence in dictionary.enumerated() &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;\(sequence.offset) --&amp;gt; \(sequence.element.key), \(sequence.element.value)&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (offset, item) in dictionary.enumerated() &#123;</span><br><span class="line"></span><br><span class="line">        print(&quot;\(offset) --&amp;gt; \(item.key), \(item.value)&quot;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/Swift4.0字典（Dictionary）学习/" data-id="cjh5uw3ht00049mxmufy6gtk6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift4-0字符串（String）学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/Swift4-0字符串（String）学习/" class="article-date">
  <time datetime="2018-05-14T06:14:23.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/Swift4-0字符串（String）学习/">Swift4.0字符串（String）学习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义字符串常量（常量只有读操作）"><a href="#定义字符串常量（常量只有读操作）" class="headerlink" title="定义字符串常量（常量只有读操作）"></a>定义字符串常量（常量只有读操作）</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let lString = &quot;constant&quot;</span><br><span class="line">let lString1: String = &quot;constant&quot;</span><br></pre></td></tr></table></figure>
<h4 id="定义字符串变量"><a href="#定义字符串变量" class="headerlink" title="定义字符串变量"></a>定义字符串变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string = &quot;&quot;</span><br><span class="line">var string1: String = &quot;哈哈&quot;</span><br><span class="line">var string2 = String()</span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string = &quot;this-is-a-string-variable&quot;</span><br></pre></td></tr></table></figure>
<h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let stringArray = string.split(separator: &quot;-&quot;) // 按&apos;-&apos;分割</span><br><span class="line">print(stringArray) // [&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;string&quot;, &quot;variable&quot;]</span><br></pre></td></tr></table></figure>
<h4 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let start = string.startIndex  // 开始下标</span><br></pre></td></tr></table></figure>
<p>let end = string.index（string.startIndex，offsetBy：7）//结束下标let subString = string [start .. <end> 1，string.startIndex表示第一个字符的下标</end></p>
<blockquote>
<p>2，string.endIndex表示最后一个字符的下标3，startIndex，endIndex是索引类型，不是Int类型</p>
</blockquote>
<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string += &quot;!&quot;       // 追加&apos;!&apos;</span><br><span class="line">print(string)       // this-is-a-string-variable!</span><br><span class="line"></span><br><span class="line">string += string1   // 追加字符串变量string1</span><br><span class="line">print(string)       // this-is-a-string-variable!哈哈</span><br><span class="line"></span><br><span class="line">let num = 100</span><br><span class="line">string = string + &quot;--\(num)&quot;</span><br><span class="line">print(string)       // this-is-a-string-variable!哈哈--100</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/Swift4-0字符串（String）学习/" data-id="cjh5uw3hq00029mxmy5xiq3ah" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="swift-Swift4.0数组（Array）之过滤器（过滤器）的使用" class="article article-type-swift" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/Swift4.0数组（Array）之过滤器（过滤器）的使用/" class="article-date">
  <time datetime="2018-05-14T06:12:10.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/Swift4.0数组（Array）之过滤器（过滤器）的使用/">4.0数组（Array）之过滤器（过滤器）的使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们先来定义一个常量整型数组</p>
<p>让array = [5，4，3，1，2]</p>
<h4 id="过滤器（过滤器）使用之筛选出大于3的值"><a href="#过滤器（过滤器）使用之筛选出大于3的值" class="headerlink" title="过滤器（过滤器）使用之筛选出大于3的值"></a>过滤器（过滤器）使用之筛选出大于3的值</h4><p>let resultArray = array.filter {（item） - &gt; Bool in return item&gt; 3} print（resultArray）// [5,4]</p>
<p>简化可以这样写</p>
<p>let resultArray = array.filter {return $ 0&gt; 3} print（resultArray）// [5，4]</p>
<blockquote>
<p>闭包中的 ‘回归’ 是可以省略的</p>
</blockquote>
<h4 id="过滤器（过滤器）使用之筛选出能被2整除的值"><a href="#过滤器（过滤器）使用之筛选出能被2整除的值" class="headerlink" title="过滤器（过滤器）使用之筛选出能被2整除的值"></a>过滤器（过滤器）使用之筛选出能被2整除的值</h4><p>let resultArray = array.filter {（item） - &gt; Bool返回项目％2 == 0} print（resultArray）// [4，2]</p>
<p>简化可以这样写</p>
<p>let resultArray = array.filter {return $ 0％2 == 0} print（resultArray）// [4，2]</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>1，过滤器（过滤器）使用并不复杂，很好掌握。2，过滤器（过滤器）不局限于以上的使用，望能举一反三。接收过滤后的结果。4，以上例子往往是通过来传递数组去实现的，有了过滤器（过滤器）可以更简单的实现，也使代码更整洁，建议合理使用过滤器（过滤器）。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/Swift4.0数组（Array）之过滤器（过滤器）的使用/" data-id="cjh5uw3hw00069mxmmftqtebv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift4.0中的错误处理及抛出错误" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/14/Swift4.0中的错误处理及抛出错误/" class="article-date">
  <time datetime="2018-05-14T06:08:21.000Z" itemprop="datePublished">2018-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/14/Swift4.0中的错误处理及抛出错误/">Swift4.0中的错误处理及抛出错误</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Swift的标准库中，很多方法名后都带有’throws’这个关键词，’throws’表示该方法在执行过程中遇到错误则抛出，但不会崩溃。</p>
<p>下面是斯威夫特标准库中的一个构造方法，字符串，数据都有该构造方法</p>
<p>public init（contentsOf url：URL）throws当我们通过该方法去构造一个实例时怎么去捕获抛出的错误呢（如果有错误）？</p>
<h4 id="捕获错误"><a href="#捕获错误" class="headerlink" title="捕获错误"></a>捕获错误</h4><p>在Swift中是通过do {} catch {}去捕获错误，如下</p>
<p>do {let data = try Data（contentsOf：URL（string：“path”）！）print（data）} catch {print（error）}</p>
<blockquote>
<p>do {}遇到错误即可中止，不会继续执行后面代码</p>
</blockquote>
<h4 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum registerError: Error &#123;</span><br><span class="line">      case invalidAccount</span><br><span class="line">      case invalidPassword</span><br><span class="line">      case otherError(description: String)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">func register(account: String, pwd: String) throws &#123;</span><br><span class="line">       guard account.characters.count&gt;6 &amp;&amp; account.characters.count&lt;16&gt;7 &amp;&amp; pwd.characters.count&amp;lt;18 else &#123;</span><br><span class="line"></span><br><span class="line">           throw registerError.invalidAccount</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // do something</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这样自定义错误和使用就完成了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/14/Swift4.0中的错误处理及抛出错误/" data-id="cjh5uw3hr00039mxmhs9yye8x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发工具" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/06/iOS开发工具/" class="article-date">
  <time datetime="2018-05-06T02:56:20.000Z" itemprop="datePublished">2018-05-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/06/iOS开发工具/">iOS开发工具</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Xcode的插件"><a href="#Xcode的插件" class="headerlink" title="Xcode的插件"></a>Xcode的插件</h3><ul>
<li>FuzzyAutocompletePlugin - 提供了除前缀匹配之外的其他更加灵活的自动补全功能，支持Xcode 5+。</li>
<li>SCXcodeMiniMap - SCXcodeMiniMap为Xcode添加了代码地图功能</li>
<li>在Github中显示 - 可以直接打开Github上当前正在编辑的行对应的提交页面。</li>
<li>BBUFullIssueNavigator - 这个插件让Xcode在问题导航栏显示所有的问题内容。</li>
<li>BBUDebuggerTuckAway - 当你开始编辑的时候帮你隐藏调试器栏的Xcode插件。</li>
<li>SCXcodeSwitchExpander - SCXcodeSwitchExpander是一个可以帮你展开switch语句的插件，还会自动帮你插入case语句。</li>
<li>VVDocumenter-Xcode - 方便的编写标准注释的Xcode插件。</li>
<li>XAlign - 一个Xcode代码自动对齐插件，它可以使用自定义的模式来对齐任何东西。</li>
<li>Cocoapods Xcode插件 - 依赖管理工具CocoaPods的Xcode插件。</li>
<li>KSImageNamed-Xcode - 提供了图片名称自动补全功能的插件。</li>
<li>ColorSense-for-Xcode - 可视化的颜色选择插件。</li>
<li>Backlight-for-XCode - 高亮当前编辑的行。</li>
<li>UIColor-Hex-Swift - 通过十六进制字符串创建autorelease颜色的便利方法。★</li>
<li>KPRunEverywhereXcodePlugin - 只需一次点击，就可以在多个iOS设备上构建，运行App。</li>
<li>RevealPlugin - 将揭示App和你的项目自动合为一体的Xcode插件。</li>
<li>RealmPlugin-生成Realm模型的Xcode插件。</li>
<li>AdjustFontSize - 使用⌘+ /⌘ - 快捷键调整字体大小。</li>
<li>Lin - 这个插件提供了NSLocalizedString的自动补全插件。</li>
<li>改写 - Xcode用于本地化的插件。</li>
<li>XCActionBar - Xcode的Alfred。</li>
<li>QuickJump - Xcode快速代码导航。</li>
<li>CATweaker - 一个用于创建漂亮的CAMediaTimingFunction曲线的插件。</li>
<li>XcodeWay - 便捷地导航到多个地方。</li>
<li>GitDiff - 将与git仓库中不同的代码高亮。</li>
<li>MCLog - 用于控制台内容筛选的插件。</li>
<li>XToDo - 一个显示项目中TODO，FIXME，??? 和!!! 列表的对话框。</li>
<li>CopyIssue - 使复制Xcode使用描述更简单。</li>
<li>RTImageAssets - 自动生成所需的全部App图标的插件。</li>
<li>BBUncrustifyPlugin-Xcode - 使用ClangFormat或Uncrustify格式化代码的插件。</li>
<li>Aviator - 这个插件将AppCode的⇧⌘T（源码/测试切换）带到Xcode中。</li>
<li>JumpMarks - 使用有序的书签为你的代码做导航。</li>
<li>XCSnippetr - 直接上传代码片段到Slack和Gist的Xcode插件。</li>
<li>Peckham - 使用#import引用项目中的任何文件，提供代码提示。</li>
<li>MLAutoReplace - 快速编码以及代码格式化插件，提升你的编码速度。</li>
<li>Chameleon - iOS（Obj-C＆Swift）的扁平化颜色框架</li>
<li>AutoHighlightSymbol - 高亮被选中的符号对应的所有实例。</li>
<li>Reveal-In-GitHub - 用一个快捷键就可以跳转到GitHub仓库的历史，责备，PR，问题，通知。</li>
<li>CleanHeaders-Xcode - 类似iSort的头文件排序和重复消除插件，让你的头文件看起来更加有序。</li>
<li>Luft - 帮助你实现轻量的View Controller的Xcode插件。</li>
</ul>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul>
<li>CrashMonkey - iOS平台的Monkey测试工具。</li>
<li>appium - Appium是一个开源自动化测试框架。用于测试原生或者混合应用程序。-robotframework-appiumlibrary - AppiumLibrary是一个用于RobotFramwork的appium测试框架。</li>
<li>黄瓜 - iOS BDD框架。</li>
<li>Kif - 一个iOS的函数式测试框架。</li>
<li>Subliminal - 一个保守的iOS集成测试框架。</li>
<li>UIAutomation - 一个使用脚本在连接着的设备上测试你的用户界面元素的JavaScript库。</li>
<li>ios-driver - 使用Selenium / WebDriver测试任何iOS原生，混合或者移动web应用。</li>
<li>Zucchini - 可视化的iOS测试框架。</li>
<li>远程 - 在Xcode内部控制你的iPhone来做端到端的测试。</li>
<li>NaughtyKeyboard - 一个危险字符串的大列表，当用户输入这些字符串使有很大的可能会造成bug，这是一个用于在你的iOS设备上测试你的应用程序的键盘。</li>
<li>PonyDebugger - 使用Chrome开发者工具对你的iOS应用进行远程网络和数据调试。</li>
<li>ios-snapshot-test-case - 使用屏幕快照的iOS单元测试。</li>
</ul>
<h3 id="Beta测试版本发布"><a href="#Beta测试版本发布" class="headerlink" title="Beta测试版本发布"></a>Beta测试版本发布</h3><ul>
<li>Crashlytics - 一个崩溃报告和beta测试服务。</li>
<li>TestFlight Beta测试 - iTunes Connect支持的beta测试服务。</li>
<li>HockeyApp - 在HockeyApp你可以发布你的应用程序的beta测试版本，收集实时的崩溃报告，获取用户反馈，分析测试覆盖率。</li>
</ul>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><ul>
<li>fastlane将所有iOS部署工具整合到一个工作流中。</li>
<li>提供部署截屏，应用程序元数据和AppStore应用程序更新，这一切只需要一个命令就可以搞定。</li>
<li>快照自动地创建全部语言和全部设备的屏幕截图。</li>
</ul>
<h3 id="应用商店"><a href="#应用商店" class="headerlink" title="应用商店"></a>应用商店</h3><ul>
<li>平均App Store评论时间这个网站可以同时跟踪AppStore上iOS和Mac两个版本的浏览次数，使用了iOS和Mac开发者的众包数据。</li>
<li>Apple的常见应用程序拒绝Styleguide一些导致应用程序被苹果拒绝的重要常见问题。</li>
<li>免费App Store Optimization Tool在关键字和竞争者的角度上，让你可视化地追踪你的App Store数据。</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><ul>
<li>Shark - 用于将.xcassets文件夹转换成一个类型安全枚举的Swift脚本。</li>
<li>R.swift - 在Swift项目中，强类型的自动补全资源名称的工具，包括图片，单元格和segue的工具。</li>
<li>SwiftGen - 生成资源的枚举，故事板，本地化字符串和UIColor。</li>
<li>本地化 - Swift - Swift 2.0实现在应用中切换语言的功能，帮助你的APP实现友善的本地化和国际化。</li>
<li>Blade - 为iOS和OS X应用生成Xcode图片目录，全局图片和其他相关的东西。</li>
<li>Retini - 一个超级简单的Retina（2x，3x）图片转换器。</li>
<li>Provisioning - 一个查看器插件，用于预览.mobileprovision文件。</li>
<li>Strsync - 自动翻译并且使.strings文件和默认语言同步。</li>
</ul>
<h3 id="设计工具设计工具"><a href="#设计工具设计工具" class="headerlink" title="设计工具设计工具"></a>设计工具设计工具</h3><p>Photoshop的插件 <img src="http://blog.cocoachina.com/uploads/attachments/641193/20180505/6f2fb8f0eb0cb48d8baee5b8ab3464be.png" alt=" QQ图片20180505155120.png "></p>
<h3 id="原型设计工具"><a href="#原型设计工具" class="headerlink" title="原型设计工具"></a>原型设计工具</h3><ul>
<li>Axure</li>
<li>流体UI</li>
<li>内裤</li>
<li>Flinto</li>
<li>Balsamiq Mockups</li>
<li>AppCooker</li>
<li>Proto.io</li>
<li>UXPin</li>
<li>的nVision</li>
<li>POP</li>
<li>快现</li>
<li>综合</li>
<li>的OmniGraffle</li>
<li>Marvelapp</li>
<li>Justinmind</li>
<li>形成</li>
<li>Prott</li>
<li>综合</li>
</ul>
<h3 id="交互设计工具"><a href="#交互设计工具" class="headerlink" title="交互设计工具"></a>交互设计工具</h3><ul>
<li>Framer Studio</li>
<li>Quartz Composer</li>
<li>折纸</li>
<li>JQC</li>
<li>鳄梨</li>
<li>Pixate</li>
</ul>
<p>UI效果预览工具</p>
<ul>
<li>Android Material Design可视化调色板</li>
<li>Android材质设计Colours.xml</li>
<li>Colorube配色神器</li>
<li>Adobe Kuler</li>
<li>ColorSchemer Studio</li>
<li>Piknik</li>
</ul>
<h3 id="手机为电脑同步预览工具"><a href="#手机为电脑同步预览工具" class="headerlink" title="手机为电脑同步预览工具"></a>手机为电脑同步预览工具</h3><ul>
<li>反光</li>
<li>蜃景</li>
<li>AirServer</li>
<li>BBQScreen</li>
</ul>
<h3 id="Design-GuidesAndroid设计指南非官方简体中文版"><a href="#Design-GuidesAndroid设计指南非官方简体中文版" class="headerlink" title="Design GuidesAndroid设计指南非官方简体中文版"></a>Design GuidesAndroid设计指南非官方简体中文版</h3><p>Topfun镜像地址：<a href="http://www.topfun.us/adchs/index.html" target="_blank" rel="noopener">http</a> : <a href="http://www.topfun.us/adchs/index.html" target="_blank" rel="noopener">//www.topfun.us/adchs/index.html</a> Github镜像地址：<a href="http://adchs.github.io/" target="_blank" rel="noopener">http:</a> //adchs.github.io ApkBus镜像地址：<a href="http://www.apkbus.com/design/" target="_blank" rel="noopener">http</a> : <a href="http://www.apkbus.com/design/" target="_blank" rel="noopener">//www.apkbus.com/design/</a> Segmentfault镜像地址：<a href="http://mirrors.segmentfault.com/adchs/" target="_blank" rel="noopener">http</a>://mirrors.segmentfault.com/adchs/多看阅读镜像地址：<a href="http://www.duokan.com/book/47790" target="_blank" rel="noopener">http</a> ://<a href="http://www.duokan.com/book/47790" target="_blank" rel="noopener">www.duokan.com/book/47790</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/06/iOS开发工具/" data-id="cjh5uw3i2000b9mxmo7d6fdyb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL命令大全" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/02/MYSQL命令大全/" class="article-date">
  <time datetime="2018-05-01T16:16:45.000Z" itemprop="datePublished">2018-05-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/02/MYSQL命令大全/">MYSQL命令大全</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>  常见的MySQL命令大全2007-11-09 17:59一、连接MySQL</p>
<p>  格式： mysql -h主机地址 -u用户名 －p用户密码</p>
<p>  1、例1：连接到本机上的MYSQL。</p>
<p>  首先在打开DOS窗口，然后进入目录 mysqlbin，再键入命令mysql -uroot -p，回车后提示你输密码，如果刚安装好MYSQL，超级用户root是没有密码的，故直接回车即可进入到MYSQL中了，MYSQL的提示符是： mysql&gt;。</p>
<p>  2、例2：连接到远程主机上的MYSQL。假设远程主机的IP为：110.110.110.110，用户名为root,密码为abcd123。则键入以下命令：</p>
<p>  mysql -h110.110.110.110 -uroot -pabcd123</p>
<p>  （注:u与root可以不用加空格，其它也一样）</p>
<p>  3、退出MYSQL命令： exit （回车）。</p>
<p>  二、修改密码</p>
<p>  格式：mysqladmin<br>  -u用户名 -p旧密码 password 新密码</p>
<p>  1、例1：给root加个密码ab12。首先在DOS下进入目录mysqlbin，然后键入以下命令：</p>
<p>  mysqladmin -uroot -password ab12</p>
<p>  注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。</p>
<p>  2、例2：再将root的密码改为djg345。</p>
<p>  mysqladmin -uroot -pab12 password djg345</p>
<p>  三、增加新用户。（注意：和上面不同，下面的因为是MySQL环境中的命令，所以后面都带一个分号作为命令结束符）</p>
<p>  格式：grant<br>  select on 数据库.* to 用户名@登录主机 identified by \”密码\”</p>
<p>  例1、增加一个用户test1密码为abc，让他可以在任何主机上登录，并对所有数据库有查询、插入、修改、删除的权限。首先用以root用户连入MySQL，然后键入以下命令：</p>
<p>  grant select,insert,update,</p>
<p>  delete on <em>.</em> to <a href="mailto:test2@localhost" target="_blank" rel="noopener">test2@localhost</a><br>  identified by \”abc\”;</p>
<p>  如果你不想test2有密码，可以再打一个命令将密码消掉。</p>
<p>  grant select,insert,update,delete on mydb</p>
<p>  .* to <a href="mailto:test2@localhost" target="_blank" rel="noopener">test2@localhost</a> identified by \”\”;</p>
<p>  在上面讲了登录、增加用户、密码更改等问题。下面我们来看看MySQL中有关数据库方面的操作。注意：你必须首先登录到MySQL中，以下操作都是在MySQL的提示符下进行的，而且每个命令以分号结束。<br>  1、MySQL常用命令<br>  create database name; 创建数据库<br>  use databasename; 选择数据库<br>  drop database name 直接删除数据库，不提醒<br>  show tables; 显示表<br>  describe tablename; 表的详细描述<br>  select 中加上distinct去除重复字段<br>  mysqladmin drop database name 删除数据库前，有提示。<br>  显示当前mysql版本和当前日期<br>  select version(),current_date;<br>  2、修改mysql中root的密码：<br>  shell&gt;mysql -u root -p<br>  mysql&gt; update user set<br>  password=password(”xueok654123″) where user=’root’;<br>  mysql&gt; flush privileges //刷新数据库<br>  mysql&gt;use dbname； 打开数据库：<br>  mysql&gt;show databases; 显示所有数据库<br>  mysql&gt;show tables; 显示数据库mysql中所有的表：先use mysql；然后<br>  mysql&gt;describe user; 显示表mysql数据库中user表的列信息）；<br>  3、grant<br>  创建一个可以从任何地方连接服务器的一个完全的超级用户，但是必须使用一个口令something做这个<br>  mysql&gt; grant all privileges on <em>.</em> to <a href="mailto:user@localhost" target="_blank" rel="noopener">user@localhost</a> identified by ’something’<br>  with<br>  增加新用户<br>  格式：grant<br>  select on 数据库.<em> to 用户名@登录主机 identified by “密码”<br>  GRANT ALL PRIVILEGES ON </em>.<em> TO <a href="mailto:monty@localhost" target="_blank" rel="noopener">monty@localhost</a> IDENTIFIED BY ’something’<br>  WITH GRANT OPTION;<br>  GRANT ALL PRIVILEGES ON </em>.<em> TO <a href="mailto:monty@" target="_blank" rel="noopener">monty@”%</a>” IDENTIFIED BY ’something’ WITH GRANT<br>  OPTION;<br>  删除授权：<br>  mysql&gt; revoke all privileges on </em>.<em><br>  from <a href="mailto:root@" target="_blank" rel="noopener">root@”%</a>”;<br>  mysql&gt; delete from user where user=”root”<br>  and host=”%”;<br>  mysql&gt; flush privileges;<br>  创建一个用户custom在特定客户端it363.com登录，可访问特定数据库fangchandb<br>  mysql &gt;grant select, insert, update,<br>  delete, create,drop on fangchandb.</em> to custom@ it363.com identified by ‘<br>  passwd’<br>  重命名表:<br>  mysql &gt; alter table t1 rename t2;<br>  4、mysqldump<br>  备份数据库<br>  shell&gt; mysqldump -h host -u root -p<br>  dbname &gt;dbname_backup.sql<br>  恢复数据库<br>  shell&gt; mysqladmin -h myhost -u root -p<br>  create dbname<br>  shell&gt; mysqldump -h host -u root -p<br>  dbname &lt; dbname_backup.sql<br>  如果只想卸出建表指令，则命令如下：<br>  shell&gt; mysqladmin -u root -p -d<br>  databasename &gt; a.sql<br>  如果只想卸出插入数据的sql命令，而不需要建表命令，则命令如下：<br>  shell&gt; mysqladmin -u root -p -t<br>  databasename &gt; a.sql<br>  那么如果我只想要数据，而不想要什么sql命令时，应该如何操作呢？<br>  　　 mysqldump<br>  -T./ phptest driver<br>  其中，只有指定了-T参数才可以卸出纯文本文件，表示卸出数据的目录，./表示当前目录，即与mysqldump同一目录。如果不指定driver 表，则将卸出整个数据库的数据。每个表会生成两个文件，一个为.sql文件，包含建表执行。另一个为.txt文件，只包含数据，且没有sql指令。<br>  5、可将查询存储在一个文件中并告诉mysql从文件中读取查询而不是等待键盘输入。可利用外壳程序键入重定向实用程序来完成这项工作。例如，如果在文件my_file.sql 中存放有查<br>  询，可如下执行这些查询：<br>  例如，如果您想将建表语句提前写在sql.txt中:<br>  mysql &gt; mysql -h myhost -u root -p<br>  database &lt; sql.txt<br>  1、安装环境：<br>        Windows XP<br>        Mysql<br>  4.0.17 从<br>  下次就需要用mysql<br>  -uroot -proot才可以登陆<br>      在远程或本机可以使用 mysql -h 172.5.1.183<br>  -uroot 登陆，这个根据第二行的策略确定<br>      权限修改生效：</p>
<p>  1)net stop mysql</p>
<p>  net start mysql</p>
<p>  2)c:\mysql\bin\mysqladmin flush-privileges<br>         3)登陆mysql后，用flush privileges语句<br>  6、创建数据库staffer<br>      create database<br>  staffer;<br>  7、下面的语句在mysql环境在执行<br>      显示用户拥有权限的数据库<br>  show databases;<br>      切换到staffer数据库<br>  use staffer;<br>      显示当前数据库中有权限的表 show tables;<br>      显示表staffer的结构    desc<br>  staffer;<br>  8、创建测试环境<br>      1)创建数据库staffer<br>        mysql&gt;<br>  create database staffer<br>      2)创建表staffer,department,position,depart_pos<br>        create<br>  table s_position<br>        (</p>
<p>  id int not null auto_increment,</p>
<p>  name varchar(20) not null default ‘经理’, #设定默认值</p>
<p>  description varchar(100),</p>
<p>  primary key PK_positon (id)   #设定主键</p>
<p>  );<br>        create<br>  table department<br>        (</p>
<p>  id int not null auto_increment,</p>
<p>  name varchar(20) not null default ‘系统部’, #设定默认值</p>
<p>  description varchar(100),</p>
<p>  primary key PK_department (id)   #设定主键<br>        );<br>        create<br>  table depart_pos<br>        (</p>
<p>  department_id int not null,</p>
<p>  position_id int not null,</p>
<p>  primary key PK_depart_pos (department_id,position_id)   #设定复和主键<br>        );<br>        create<br>  table staffer<br>        (</p>
<p>  id int not null auto_increment primary key,   #设定主键</p>
<p>  name varchar(20) not null default ‘无名氏’,   #设定默认值</p>
<p>  department_id int not null,</p>
<p>  position_id int not null,</p>
<p>  unique (department_id,position_id)   #设定唯一值<br>        );<br>      3)删除<br>        mysql&gt;</p>
<p>  drop table depart_pos;</p>
<p>  drop table department;</p>
<p>  drop table s_position;</p>
<p>  drop table staffer;</p>
<p>  drop database staffer;<br>  9、修改结构<br>      mysql&gt;</p>
<pre><code>#表position增加列test
</code></pre><p>​      alter table position<br>  add(test char(10));</p>
<pre><code>#表position修改列test
</code></pre><p>​      alter table position<br>  modify test char(20) not null;</p>
<pre><code>#表position修改列test默认值
</code></pre><p>​      alter table position<br>  alter test set default ‘system’;</p>
<pre><code>#表position去掉test默认值
</code></pre><p>​      alter table position<br>  alter test drop default;</p>
<pre><code>#表position去掉列test
</code></pre><p>​      alter table position<br>  drop column test;</p>
<pre><code>#表depart_pos删除主键
</code></pre><p>​      alter table depart_pos<br>  drop primary key;</p>
<pre><code>#表depart_pos增加主键
</code></pre><p>​      alter table depart_pos<br>  add primary key PK_depart_pos (department_id,position_id);<br>  10、操作数据</p>
<pre><code>#插入表department
</code></pre><p>​      insert into<br>  department(name,description) values(‘系统部’,’系统部’);<br>      insert into<br>  department(name,description) values(‘公关部’,’公关部’);<br>      insert into<br>  department(name,description) values(‘客服部’,’客服部’);<br>      insert into<br>  department(name,description) values(‘财务部’,’财务部’);<br>      insert into<br>  department(name,description) values(‘测试部’,’测试部’);</p>
<pre><code>#插入表s_position
</code></pre><p>​      insert into<br>  s_position(name,description) values(‘总监’,’总监’);<br>      insert into<br>  s_position(name,description) values(‘经理’,’经理’);<br>      insert into<br>  s_position(name,description) values(‘普通员工’,’普通员工’);</p>
<pre><code>#插入表depart_pos
</code></pre><p>​      insert into<br>  depart_pos(department_id,position_id)<br>      select a.id<br>  department_id,b.id postion_id<br>      from department<br>  a,s_position b;</p>
<pre><code>#插入表staffer
</code></pre><p>​      insert into<br>  staffer(name,department_id,position_id) values(‘陈达治’,1,1);<br>      insert into<br>  staffer(name,department_id,position_id) values(‘李文宾’,1,2);<br>      insert into<br>  staffer(name,department_id,position_id) values(‘马佳’,1,3);<br>      insert into<br>  staffer(name,department_id,position_id) values(‘亢志强’,5,1);<br>      insert into<br>  staffer(name,department_id,position_id) values(‘杨玉茹’,4,1);<br>  11、查询及删除操作</p>
<pre><code>#显示系统部的人员和职位
</code></pre><p>​      select a.name,b.name<br>  department_name,c.name position_name<br>      from staffer<br>  a,department b,s_position c<br>      where<br>  a.department_id=b.id and a.position_id=c.id and b.name=’系统部’;</p>
<pre><code>#显示系统部的人数
</code></pre><p>​      select count(*) from<br>  staffer a,department b<br>      where<br>  a.department_id=b.id and b.name=’系统部’</p>
<pre><code>#显示各部门的人数
</code></pre><p>​      select count(*)<br>  cou,b.name<br>      from staffer<br>  a,department b<br>      where<br>  a.department_id=b.id<br>      group by b.name;</p>
<pre><code>#删除客服部
</code></pre><p>​      delete from department<br>  where name=’客服部’;</p>
<pre><code>#将财务部修改为财务一部
</code></pre><p>​      update department set<br>  name=’财务一部’ where<br>  name=’财务部’;<br>  12、备份和恢复<br>       备份数据库staffer</p>
<p>  c:\mysql\bin\mysqldump -uroot -proot staffer&gt;e:\staffer.sql<br>        得到的staffer.sql是一个sql脚本，不包括建库的语句，所以你需要手工<br>        创建数据库才可以导入<br>       恢复数据库staffer,需要创建一个空库staffer</p>
<p>  c:\mysql\bin\mysql -uroot -proot staffer&lt;staffer.sql<br>        如果不希望后来手工创建staffer,可以</p>
<p>  c:\mysql\bin\mysqldump -uroot -proot –databases staffer&gt;e:\staffer.sql<br>        mysql<br>  -uroot -proot &gt;e:\staffer.sql<br>        但这样的话系统种就不能存在staffer库，且无法导入其他名字的数据库，<br>        当然你可以手工修改staffer.sql文件<br>  13、从文本向数据库导入数据<br>       1)使用工具c:\mysql\bin\mysqlimport<br>       这个工具的作用是将文件导入到和去掉文件扩展名名字相同的表里，如</p>
<p>  staffer.txt,staffer都是导入到staffer表中<br>       常用选项及功能如下<br>  -d or –delete 新数据导入数据表中之前删除数据数据表中的所有信息<br>  -f or –force 不管是否遇到错误，mysqlimport将强制继续插入数据<br>  -i or –ignore mysqlimport跳过或者忽略那些有相同唯一<br>  关键字的行， 导入文件中的数据将被忽略。<br>  -l or -lock-tables 数据被插入之前锁住表，这样就防止了，<br>  你在更新数据库时，用户的查询和更新受到影响。<br>  -r or -replace 这个选项与－i选项的作用相反；此选项将替代<br>  表中有相同唯一关键字的记录。<br>  –fields-enclosed- by= char<br>  指定文本文件中数据的记录时以什么括起的， 很多情况下<br>  数据以双引号括起。 默认的情况下数据是没有被字符括起的。<br>  –fields-terminated- by=char<br>  指定各个数据的值之间的分隔符，在句号分隔的文件中，<br>  分隔符是句号。您可以用此选项指定数据之间的分隔符。<br>  默认的分隔符是跳格符（Tab）<br>  –lines-terminated- by=str<br>  此选项指定文本文件中行与行之间数据的分隔字符串<br>  或者字符。 默认的情况下mysqlimport以newline为行分隔符。<br>  您可以选择用一个字符串来替代一个单个的字符：<br>  一个新行或者一个回车。<br>  mysqlimport命令常用的选项还有-v 显示版本（version），</p>
<p>  -p 提示输入密码（password）等。<br>      这个工具有个问题，无法忽略某些列，这样对我们的数据导入有很大的麻烦，虽然<br>      可以手工设置这个字段，但会出现莫名其妙的结果，我们做一个简单的示例<br>      我们定义如下的depart_no.txt，保存在e盘，间隔为制表符\t<br>  10 10<br>  11 11<br>  12 24<br>  执行如下命令<br>       c:\mysql\bin\mysqlimport<br>  -uroot -proot staffer e:\depart_pos.txt<br>       在这里没有使用列的包围符号，分割采用默认的\t，因为采用别的符号会有问题，<br>       不知道是不是windows的原因<br>       2)Load Data<br>  INFILE file_name into table_name(column1_name,column2_name)<br>         这个命令在mysql&gt;提示符下使用，优点是可以指定列导入，示例如下<br>         c:\mysql\bin\mysql<br>  -uroot -proot staffer</p>
<p>  mysql&gt;load data infile “e:/depart_no.txt” into<br>  depart_no(department_id,position_id);</p>
<p>​       这两个工具在Windows下使用都有问题，不知道是Windows的原因还是中文的问题，<br>       而且不指定的列它产生了空值，这显然不是我们想要的，所以谨慎使用这些工具<br>  进入MySQL:mysql<br>  -uuser -ppassword –port=3307<br>  1:使用SHOW语句找出在服务器上当前存在什么数据库：<br>  mysql&gt; SHOW DATABASES;<br>  2:2、创建一个数据库MYSQLDATA<br>  mysql&gt; Create DATABASE MYSQLDATA;<br>  3:选择你所创建的数据库<br>  mysql&gt; USE MYSQLDATA; (按回车键出现Database changed 时说明操作成功！)<br>  4:查看现在的数据库中存在什么表<br>  mysql&gt; SHOW TABLES;<br>  5:创建一个数据库表<br>  mysql&gt; Create TABLE MYTABLE (name<br>  VARCHAR(20), sex CHAR(1));<br>  6:显示表的结构：<br>  mysql&gt; DESCRIBE MYTABLE;<br>  7:往表中加入记录<br>  mysql&gt; insert into MYTABLE values<br>  (“hyq”,”M”);<br>  8:用文本方式将数据装入数据库表中（例如D:/mysql.txt）<br>  mysql&gt; LOAD DATA LOCAL INFILE<br>  “D:/mysql.txt” INTO TABLE MYTABLE;<br>  9:导入.sql文件命令（例如D:/mysql.sql）<br>  mysql&gt;use database;<br>  mysql&gt;source d:/mysql.sql;<br>  10:删除表<br>  mysql&gt;drop TABLE MYTABLE;<br>  11:清空表<br>  mysql&gt;delete from MYTABLE;<br>  12:更新表中数据<br>  mysql&gt;update MYTABLE set<br>  sex=”f” where name=’hyq’;<br>  UPDATE [LOW_PRIORITY] [IGNORE] tbl_name<br>      SET col_name1=expr1 [,<br>  col_name2=expr2 …]<br>      [WHERE<br>  where_definition]<br>      [ORDER BY …]<br>      [LIMIT rows]<br>  or<br>  UPDATE [LOW_PRIORITY] [IGNORE] tbl_name<br>  [, tbl_name …]<br>      SET col_name1=expr1 [,<br>  col_name2=expr2 …]<br>      [WHERE<br>  where_definition]<br>  UPDATE 以新的值更新现存表中行的列。SET 子句指出要修改哪个列和他们应该给定的值。WHERE<br>        子句如果被给出，指定哪个记录行应该被更新。否则，所有的记录行被更新。如果 ORDER BY 子句被指定，记录行将被以指定的次序更新。<br>        如果你指定关键词 LOW_PRIORITY，UPDATE 的执行将被延迟，直到没有其它的客户端正在读取表。<br>        如果你指定关键词 IGNORE，该更新语句将不会异常中止，即使在更新过程中出现重复键错误。导致冲突的记录行将不会被更新。<br>        如果在一个表达式中从 tbl_name 中访问一个列，UPDATE 使用列的当前值。举例来说，下面的语句设置 age 列值为它的当前值加 1 ：<br>  mysql&gt; UPDATE persondata SET<br>  age=age+1;<br>  UPDATE 赋值是从左到右计算的。举例来说，下列语句将 age 列设置为它的两倍，然后再加 1 ：<br>  mysql&gt; UPDATE persondata SET<br>  age=age<em>2, age=age+1;<br>  如果你设置列为其当前的值，MySQL 注意到这点，并不更新它。<br>        UPDATE 返回实际被改变的记录行数目。在 MySQL 3.22 或更新的版本中，C API 函数 mysql_info()<br>        返回被匹配并更新的记录行数目，以及在 UPDATE 期间发生的警告的数目。<br>        在 MySQL 3.23 中，你可以使用 LIMIT # 来确保只有给定的记录行数目被更改。<br>        如果一个 ORDER BY 子句被使用(从 MySQL 4.0.0 开始支持)，记录行将以指定的次序被更新。这实际上只有连同 LIMIT<br>        一起才有用。<br>        从 MySQL 4.0.4 开始，你也可以执行一个包含多个表的 UPDATE 的操作：<br>  UPDATE items,month SET<br>  items.price=month.price<br>  WHERE items.id=month.id;<br>  注意：多表 UPDATE<br>  不可以使用 ORDER<br>  BY 或 LIMIT。<br>  关键字:<br>  mysql<br>  启动：net start<br>  mySql;<br>  　　进入：mysql<br>  -u root -p/mysql -h localhost -u root -p databaseName;<br>  　　列出数据库：show<br>  databases;<br>  　　选择数据库：use<br>  databaseName;<br>  　　列出表格：show<br>  tables；<br>  　　显示表格列的属性：show<br>  columns from tableName；<br>  　　建立数据库：source<br>  fileName.txt;<br>  　　匹配字符：可以用通配符_代表任何一个字符，％代表任何字符串;<br>  　　增加一个字段：alter<br>  table tabelName add column fieldName dateType;<br>  　　增加多个字段：alter<br>  table tabelName add column fieldName1 dateType,add columns fieldName2<br>  dateType;<br>  　　多行命令输入:注意不能将单词断开;当插入或更改数据时，不能将字段的字符串展开到多行里，否则硬回车将被储存到数据中;<br>  　　增加一个管理员帐户：grant<br>  all on </em>.<em> to <a href="mailto:user@localhost" target="_blank" rel="noopener">user@localhost</a> identified<br>  by “password”;<br>  　　每条语句输入完毕后要在末尾填加分号’;’，或者填加’\g’也可以；<br>  　　查询时间：select<br>  now();<br>  　　查询当前用户：select<br>  user();<br>  　　查询数据库版本：select<br>  version();<br>  　　查询当前使用的数据库：select database();<br>  　　<br>  　　1、删除student_course数据库中的students数据表：<br>  　　rm -f<br>  student_course/students.</em><br>  　　<br>  　　2、备份数据库：(将数据库test备份)<br>  　　mysqldump<br>  -u root -p test&gt;c:\test.txt<br>  　　备份表格：(备份test数据库下的mytable表格)<br>  　　mysqldump<br>  -u root -p test mytable&gt;c:\test.txt<br>  　　将备份数据导入到数据库：(导回test数据库)<br>  　　mysql -u<br>  root -p test<br>  　　<br>  　　3、创建临时表：(建立临时表zengchao)<br>  　　create<br>  temporary table zengchao(name varchar(10));<br>  　　<br>  　　4、创建表是先判断表是否存在<br>  　　create<br>  table if not exists students(……);<br>  　　<br>  　　5、从已经有的表中复制表的结构<br>  　　create<br>  table table2 select <em> from table1 where 1&lt;&gt;1;<br>  　　<br>  　　6、复制表<br>  　　create<br>  table table2 select </em> from table1;<br>  　　<br>  　　7、对表重新命名<br>  　　alter<br>  table table1 rename as table2;<br>  　　<br>  　　8、修改列的类型<br>  　　alter<br>  table table1 modify id int unsigned;//修改列id的类型为int<br>  unsigned<br>  　　alter<br>  table table1 change id sid int unsigned;//修改列id的名字为sid，而且把属性修改为int unsigned<br>  　　<br>  　　9、创建索引<br>  　　alter<br>  table table1 add index ind_id (id);<br>  　　create<br>  index ind_id on table1 (id);<br>  　　create<br>  unique index ind_id on table1 (id);//建立唯一性索引<br>  　　<br>  　　10、删除索引<br>  　　drop index<br>  idx_id on table1;<br>  　　alter<br>  table table1 drop index ind_id;<br>  　　<br>  　　11、联合字符或者多个列(将列id与”:”和列name和”=”连接)<br>  　　select<br>  concat(id,’:’,name,’=’) from students;<br>  　　<br>  　　12、limit(选出10到20条)&lt;第一个记录集的编号是0&gt;<br>  　　select <em><br>  from students order by id limit 9,10;<br>  　　<br>  　　13、MySQL不支持的功能<br>  　　事务，视图，外键和引用完整性，存储过程和触发器<br>  　　<br>  　　<br>  　　14、MySQL会使用索引的操作符号<br>  　　&lt;,&lt;=,&gt;=,&gt;,=,between,in,不带%或者_开头的like<br>  　　<br>  　　15、使用索引的缺点<br>  　　1)减慢增删改数据的速度；<br>  　　2）占用磁盘空间；<br>  　　3）增加查询优化器的负担；<br>  　　当查询优化器生成执行计划时，会考虑索引，太多的索引会给查询优化器增加工作量，导致无法选择最优的查询方案；<br>  　　<br>  　　16、分析索引效率<br>  　　方法：在一般的SQL语句前加上explain；<br>  　　分析结果的含义：<br>  　　1）table：表名；<br>  　　2）type：连接的类型，(ALL/Range/Ref)。其中ref是最理想的；<br>  　　3）possible_keys：查询可以利用的索引名；<br>  　　4）key：实际使用的索引；<br>  　　5）key_len：索引中被使用部分的长度（字节）；<br>  　　6）ref：显示列名字或者”const”（不明白什么意思）；<br>  　　7）rows：显示MySQL认为在找到正确结果之前必须扫描的行数；<br>  　　8）extra：MySQL的建议；<br>  　　<br>  　　17、使用较短的定长列<br>  　　1）尽可能使用较短的数据类型；<br>  　　2）尽可能使用定长数据类型；<br>  　　a）用char代替varchar，固定长度的数据处理比变长的快些；<br>  　　b）对于频繁修改的表，磁盘容易形成碎片，从而影响数据库的整体性能；<br>  　　c）万一出现数据表崩溃，使用固定长度数据行的表更容易重新构造。使用固定长度的数据行，每个记录的开始位置都是固定记录长度的倍数，可以很容易被检测到，但是使用可变长度的数据行就不一定了；<br>  　　d）对于MyISAM类型的数据表，虽然转换成固定长度的数据列可以提高性能，但是占据的空间也大；<br>  　　<br>  　　18、使用not null和enum<br>  　　尽量将列定义为not<br>  null，这样可使数据的出来更快，所需的空间更少，而且在查询时，MySQL不需要检查是否存在特例，即null值，从而优化查询；<br>  　　如果一列只含有有限数目的特定值，如性别，是否有效或者入学年份等，在这种情况下应该考虑将其转换为enum列的值，MySQL处理的更快，因为所有的enum值在系统内都是以标识数值来表示的；<br>  　　<br>  　　19、使用optimize table<br>  　　对于经常修改的表，容易产生碎片，使在查询数据库时必须读取更多的磁盘块，降低查询性能。具有可变长的表都存在磁盘碎片问题，这个问题对blob数据类型更为突出，因为其尺寸变化非常大。可以通过使用optimize table来整理碎片，保证数据库性能不下降，优化那些受碎片影响的数据表。 optimize table可以用于MyISAM和BDB类型的数据表。实际上任何碎片整理方法都是用mysqldump来转存数据表，然后使用转存后的文件并重新建数据表；<br>  　　<br>  　　20、使用procedure analyse()<br>  　　可以使用procedure<br>  analyse()显示最佳类型的建议，使用很简单，在select语句后面加上procedure analyse()就可以了；例如：<br>  　　select </em><br>  from students procedure analyse();<br>  　　select *<br>  from students procedure analyse(16,256);<br>  　　第二条语句要求procedure<br>  analyse()不要建议含有多于16个值，或者含有多于256字节的enum类型，如果没有限制，输出可能会很长；<br>  　　<br>  　　21、使用查询缓存<br>  　　1）查询缓存的工作方式：<br>  　　第一次执行某条select语句时，服务器记住该查询的文本内容和查询结果，存储在缓存中，下次碰到这个语句时，直接从缓存中返回结果；当更新数据表后，该数据表的任何缓存查询都变成无效的，并且会被丢弃。<br>  　　2）配置缓存参数：<br>  　　变量：query_cache<br>  _type，查询缓存的操作模式。有3中模式，0：不缓存；1：缓存查询，除非与 select sql_no_cache开头；2：根据需要只缓存那些以select sql_cache开头的查询； query_cache_size：设置查询缓存的最大结果集的大小，比这个值大的不会被缓存。<br>  　　<br>  　　22、调整硬件<br>  　　1）在机器上装更多的内存；<br>  　　2）增加更快的硬盘以减少I/O等待时间；<br>  　　寻道时间是决定性能的主要因素，逐字地移动磁头是最慢的，一旦磁头定位，从磁道读则很快；<br>  　　3）在不同的物理硬盘设备上重新分配磁盘活动；<br>  　　如果可能，应将最繁忙的数据库存放在不同的物理设备上，这跟使用同一物理设备的不同分区是不同的，因为它们将争用相同的物理资源（磁头）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/02/MYSQL命令大全/" data-id="cjh5uw3hv00059mxmfblk1ueb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-GitHub最著名的20个Python机器学习项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/01/GitHub最著名的20个Python机器学习项目/" class="article-date">
  <time datetime="2018-05-01T15:35:40.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/01/GitHub最著名的20个Python机器学习项目/">GitHub最著名的20个Python机器学习项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>1</strong></p>
<p>Scikit-learn：Scikit-learn 是基于Scipy为机器学习建造的的一个Python模块，他的特色就是多样化的分类，回归和聚类的算法包括支持向量机，逻辑回归，朴素贝叶斯分类器，随机森林，Gradient Boosting，聚类算法和DBSCAN。而且也设计出了Python numerical和scientific libraries Numpy and Scipy</p>
<p><a href="https://github.com/scikit-learn/scikit-learn" target="_blank" rel="noopener">https://github.com/scikit-learn/scikit-learn</a></p>
<p><strong>2</strong></p>
<p>Pylearn2：Pylearn是一个让机器学习研究简单化的基于Theano的库程序。</p>
<p><a href="https://github.com/lisa-lab/pylearn2" target="_blank" rel="noopener">https://github.com/lisa-lab/pylearn2</a></p>
<p><strong>3</strong></p>
<p>NuPIC：NuPIC是一个以HTM学习算法为工具的机器智能平台。HTM是皮层的精确计算方法。HTM的核心是基于时间的持续学习算法和储存和撤销的时空模式。NuPIC适合于各种各样的问题,尤其是检测异常和预测的流数据来源。</p>
<p><a href="https://github.com/numenta/nupic" target="_blank" rel="noopener">https://github.com/numenta/nupic</a></p>
<p><strong>4</strong></p>
<p>Nilearn：Nilearn 是一个能够快速统计学习神经影像数据的Python模块。它利用Python语言中的scikit-learn 工具箱和一些进行预测建模，分类，解码，连通性分析的应用程序来进行多元的统计。</p>
<p><a href="https://github.com/nilearn/nilearn" target="_blank" rel="noopener">https://github.com/nilearn/nilearn</a></p>
<p><strong>5</strong></p>
<p>PyBrain：Pybrain是基于Python语言强化学习，人工智能，神经网络库的简称。 它的目标是提供灵活、容易使用并且强大的机器学习算法和进行各种各样的预定义的环境中测试来比较你的算法。</p>
<p><a href="https://github.com/pybrain/pybrain" target="_blank" rel="noopener">https://github.com/pybrain/pybrain</a></p>
<p><strong>6</strong></p>
<p>Pattern：Pattern 是Python语言下的一个网络挖掘模块。它为数据挖掘，自然语言处理，网络分析和机器学习提供工具。它支持向量空间模型、聚类、支持向量机和感知机并且用KNN分类法进行分类。</p>
<p><a href="https://github.com/clips/pattern" target="_blank" rel="noopener">https://github.com/clips/pattern</a></p>
<p><strong>7</strong></p>
<p>Fuel：Fuel为你的机器学习模型提供数据。他有一个共享如MNIST, CIFAR-10 (图片数据集), Google’s One Billion Words (文字)这类数据集的接口。你使用他来通过很多种的方式来替代自己的数据。</p>
<p><a href="http://www.github.com/mila-udem/fuel" target="_blank" rel="noopener">http://www.github.com/mila-udem/fuel</a></p>
<p><strong>8</strong></p>
<p>Bob：Bob是一个免费的信号处理和机器学习的工具。它的工具箱是用Python和C++语言共同编写的，它的设计目的是变得更加高效并且减少开发时间，它是由处理图像工具,音频和视频处理、机器学习和模式识别的大量软件包构成的。</p>
<p><a href="http://www.github.com/idiap/bob" target="_blank" rel="noopener">www.github.com/idiap/bob</a></p>
<p><strong>9</strong></p>
<p>Skdata：Skdata是机器学习和统计的数据集的库程序。这个模块对于玩具问题，流行的计算机视觉和自然语言的数据集提供标准的Python语言的使用。</p>
<p><a href="http://www.github.com/jaberg/skdata" target="_blank" rel="noopener">www.github.com/jaberg/skdata</a></p>
<p><strong>10</strong></p>
<p>MILK：MILK是Python语言下的机器学习工具包。它主要是在很多可得到的分类比如SVMS,K-NN,随机森林，决策树中使用监督分类法。 它还执行特征选择。 这些分类器在许多方面相结合,可以形成不同的例如无监督学习、密切关系金传播和由MILK支持的K-means聚类等分类系统。</p>
<p><a href="http://www.github.com/luispedro/milk" target="_blank" rel="noopener">www.github.com/luispedro/milk</a></p>
<p><strong>11</strong></p>
<p>IEPY：IEPY是一个专注于关系抽取的开源性信息抽取工具。它主要针对的是需要对大型数据集进行信息提取的用户和想要尝试新的算法的科学家。</p>
<p><a href="http://www.github.com/machinalis/iepy" target="_blank" rel="noopener">www.github.com/machinalis/iepy</a></p>
<p><strong>12</strong></p>
<p>Quepy：Quepy是通过改变自然语言问题从而在数据库查询语言中进行查询的一个Python框架。他可以简单的被定义为在自然语言和数据库查询中不同类型的问题。所以，你不用编码就可以建立你自己的一个用自然语言进入你的数据库的系统。现在Quepy提供对于Sparql和MQL查询语言的支持。并且计划将它延伸到其他的数据库查询语言。</p>
<p><a href="http://www.github.com/machinalis/quepy" target="_blank" rel="noopener">www.github.com/machinalis/quepy</a></p>
<p><strong>13</strong></p>
<p>Hebel：Hebel是在Python语言中对于神经网络的深度学习的一个库程序，它使用的是通过PyCUDA来进行GPU和CUDA的加速。它是最重要的神经网络模型的类型的工具而且能提供一些不同的活动函数的激活功能，例如动力，涅斯捷罗夫动力，信号丢失和停止法。</p>
<p><a href="http://www.github.com/hannes-brt/hebel" target="_blank" rel="noopener">www.github.com/hannes-brt/hebel</a></p>
<p><strong>14</strong></p>
<p>mlxtend：它是一个由有用的工具和日常数据科学任务的扩展组成的一个库程序。</p>
<p><a href="http://www.github.com/rasbt/mlxtend" target="_blank" rel="noopener">www.github.com/rasbt/mlxtend</a></p>
<p><strong>15</strong></p>
<p>nolearn：这个程序包容纳了大量能对你完成机器学习任务有帮助的实用程序模块。其中大量的模块和scikit-learn一起工作，其它的通常更有用。</p>
<p><a href="http://www.github.com/dnouri/nolearn" target="_blank" rel="noopener">www.github.com/dnouri/nolearn</a></p>
<p><strong>16</strong></p>
<p>Ramp：Ramp是一个在Python语言下制定机器学习中加快原型设计的解决方案的库程序。他是一个轻型的pandas-based机器学习中可插入的框架，它现存的Python语言下的机器学习和统计工具（比如scikit-learn,rpy2等）Ramp提供了一个简单的声明性语法探索功能从而能够快速有效地实施算法和转换。</p>
<p><a href="http://www.github.com/kvh/ramp" target="_blank" rel="noopener">www.github.com/kvh/ramp</a></p>
<p><strong>17</strong></p>
<p>Feature Forge：这一系列工具通过与scikit-learn兼容的API，来创建和测试机器学习功能。这个库程序提供了一组工具，它会让你在许多机器学习程序使用中很受用。当你使用scikit-learn这个工具时，你会感觉到受到了很大的帮助。（虽然这只能在你使用不同的算法时起作用。）</p>
<p><a href="http://www.github.com/machinalis/featureforge" target="_blank" rel="noopener">www.github.com/machinalis/featureforge</a></p>
<p><strong>18</strong></p>
<p>REP：REP是以一种和谐、可再生的方式为指挥数据移动驱动所提供的一种环境。它有一个统一的分类器包装来提供各种各样的操作，例如TMVA, Sklearn, XGBoost, uBoost等等。并且它可以在一个群体以平行的方式训练分类器。同时它也提供了一个交互式的情节。</p>
<p><a href="http://www.github.com/yandex/rep" target="_blank" rel="noopener">www.github.com/yandex/rep</a></p>
<p><strong>19</strong></p>
<p>Python 学习机器样本：用亚马逊的机器学习建造的简单软件收集。</p>
<p><a href="http://www.github.com/awslabs/machine-learning-samples" target="_blank" rel="noopener">www.github.com/awslabs/machine-learning-samples</a></p>
<p><strong>20</strong></p>
<p>Python-ELM：这是一个在Python语言下基于scikit-learn的极端学习机器的实现。</p>
<p><a href="http://www.github.com/dclambert/Python-ELM" target="_blank" rel="noopener">www.github.com/dclambert/Python-ELM</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/01/GitHub最著名的20个Python机器学习项目/" data-id="cjh5uw3hj00009mxm4kbodwqd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="mac-终端命令行补充" class="article article-type-mac" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/05/01/终端命令行补充/" class="article-date">
  <time datetime="2018-05-01T15:02:18.000Z" itemprop="datePublished">2018-05-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/01/终端命令行补充/">终端命令行补充</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="一、man"><a href="#一、man" class="headerlink" title="一、man"></a>一、man</h3><p>我们在使用一些程序的时候，可能并不知道他都有哪些命令，这个是时候我们就可以用man命令了。man全称manual 用户手册的意思</p>
<p>获取 ls 的帮助</p>
<p>$ man ls</p>
<p>查看有多少（针对不同方面的）同名的手册</p>
<p>$ man -f ls</p>
<p>ls (1) - list directory contents</p>
<p>ls (1p) - list directory contents</p>
<p>查看特定的手册</p>
<p>$ man 1p ls</p>
<p>退出man</p>
<p>执行以后，在 man page 页面中按 q 退出</p>
<h3 id="二、help"><a href="#二、help" class="headerlink" title="二、help"></a>二、help</h3><p>help一看名字就知道是什么意思了，一般程序都会有这个参数，会输出最简单有用的介绍。</p>
<p>$ man –help ### 获取 man 的帮助</p>
<p>$ ls –help ### 获取 ls 的帮助</p>
<h3 id="三、光标"><a href="#三、光标" class="headerlink" title="三、光标"></a>三、光标</h3><p>up(方向键上) 可以调出输入历史执行记录，快速执行命令</p>
<p>down(方向键下) 配合 up 选择历史执行记录</p>
<p>Home 移动光标到本行开头</p>
<p>End 移动光标到本行结尾</p>
<p>PgUp 向上翻页</p>
<p>PaDN 向下翻页</p>
<p>在苹果Mac电脑的键盘上没有Home, End, Page UP, Page DOWN这些键，可以通过用Fn键来组合得到同样的功能：Home键=Fn+左方向、End键=Fn+右方向、PageUP=Fn+上方向、PageDOWN=Fn+下方向</p>
<h3 id="四、终止当前程序"><a href="#四、终止当前程序" class="headerlink" title="四、终止当前程序"></a>四、终止当前程序</h3><p>1</p>
<p>ctrl + c 终止当前程序</p>
<p>Tab 补全</p>
<p>Tab补全是非常有用的一个功能，可以用来自动补全命令或文件名</p>
<p>未输入状态下连按两次 Tab 列出所有可用命令 已输入部分命令名或文件名，按 Tab 进行自动补全 在我输入De以后按Tab键，会补全Desktop/，然后在连续按下两次Tab键，会查看Desktop/下所有的目录</p>
<h3 id="五、cd"><a href="#五、cd" class="headerlink" title="五、cd"></a>五、cd</h3><p>cd 就是根据路径找到文件</p>
<p>譬如桌面有一个Text文件</p>
<ul>
<li>绝对路径:绝对路径强调从 /起，一直到所在路径cd Desktop/Text</li>
<li>相对路径: 直接cd Text</li>
<li>代表当前目录；.. 代表上级目录；上级目录可以 cd ..</li>
</ul>
<h3 id="六、ls"><a href="#六、ls" class="headerlink" title="六、ls"></a>六、ls</h3><p>$ ls ### 仅列出当前目录可见文件</p>
<p>$ ls -l ### 列出当前目录可见文件详细信息</p>
<p>$ ls -hl ### 列出详细信息并以可读大小显示文件大小</p>
<p>$ ls -al ### 列出所有文件（包括隐藏）的详细信息</p>
<h3 id="七、more"><a href="#七、more" class="headerlink" title="七、more"></a>七、more</h3><p>一般当文档太长的时候，我们屏幕一屏显示不完全，这个时候我们就需要使用more命令了，more 逐行显示内容</p>
<h3 id="八、less"><a href="#八、less" class="headerlink" title="八、less"></a>八、less</h3><p>less 与 more 相似，不过 less 支持上下滚动查看内容，而 more 只支持逐行显示。</p>
<h3 id="九、重启命令"><a href="#九、重启命令" class="headerlink" title="九、重启命令"></a>九、重启命令</h3><p>reboot 为重启命令</p>
<p>reboot</p>
<p>‘$’和 ‘#’的区别在于 ‘$’普通用户即可执行</p>
<p>而 ‘#’为 root 用户才可执行，或普通用户使用 ‘sudo’</p>
<h3 id="十、关机命令"><a href="#十、关机命令" class="headerlink" title="十、关机命令"></a>十、关机命令</h3><p>poweroff 为关机命令</p>
<p>poweroff 马上关机</p>
<h3 id="十一、ping"><a href="#十一、ping" class="headerlink" title="十一、ping"></a>十一、ping</h3><p>ping主要用于测试网络连通，通过对目标机器发送数据包来测试两台主机是否连通，及延时情况 通过域名 ping，若 DNS 未设置好，可能无法 ping 通</p>
<h3 id="十二、获取网络参数"><a href="#十二、获取网络参数" class="headerlink" title="十二、获取网络参数"></a>十二、获取网络参数</h3><p>ifconfig命令被用于配置和显示Linux内核中网络接口的网络参数。用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/01/终端命令行补充/" data-id="cjh5uw3i5000e9mxmjfc0g74m" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift-八种排序算法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/13/Swift-八种排序算法/" class="article-date">
  <time datetime="2018-04-13T09:50:27.000Z" itemprop="datePublished">2018-04-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/13/Swift-八种排序算法/">Swift-八种排序算法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>一、冒泡排序（Bubble Sort）</strong></p>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p><strong>1.1算法复杂度</strong></p>
<p>时间平均复杂度：O(n^2) 最坏复杂度:O(n^2) 最好复杂度: O(n) 空间复杂度: O(1) 稳定</p>
<p><strong>1.2算法过程描述</strong></p>
<ul>
<li><1>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</1></li>
<li><2>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</2></li>
<li><3>针对所有的元素重复以上的步骤，除了最后一个；</3></li>
<li><4>重复步骤1~3，直到排序完成。</4></li>
</ul>
<p><strong>1.3代码实现</strong></p>
<p><img src="Users/sundusk/Desktop/MyBlog/source/_posts/八种排序算法/排序算法-1" alt="img"></p>
<p>冒泡排序</p>
<p><strong>1.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a36ad0bb9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>冒泡排序Log1</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a36a75692a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>冒泡排序Log2</p>
<p><strong>二、选择排序（Selection Sort）</strong></p>
<p>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<p><strong>2.1算法复杂度</strong></p>
<p>时间平均复杂度：O(n^2) 最坏复杂度:O(n^2) 最好复杂度: O(n^2) 空间复杂度: O(1) 不稳定</p>
<p><strong>2.2算法过程描述</strong></p>
<p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li><1>初始状态：无序区为R[1..n]，有序区为空；</1></li>
<li><2>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</2></li>
<li><3>n-1趟结束，数组有序化了。</3></li>
</ul>
<p><strong>2.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a372269c01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>选择排序</p>
<p><strong>2.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a339c918fe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>选择排序Log</p>
<p><strong>三、插入排序（Insertion Sort）</strong></p>
<p>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
<p><strong>3.1算法复杂度</strong></p>
<p>时间平均复杂度：O(n^2) 最坏复杂度:O(n^2) 最好复杂度: O(n) 空间复杂度: O(1) 稳定</p>
<p><strong>3.2算法过程描述</strong></p>
<p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li><1>从第一个元素开始，该元素可以认为已经被排序；</1></li>
<li><2>取出下一个元素，在已经排序的元素序列中从后向前扫描；</2></li>
<li><3>如果该元素（已排序）大于新元素，将该元素移到下一位置；</3></li>
<li><4>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</4></li>
<li><5>将新元素插入到该位置后；</5></li>
<li><6>重复步骤2~5。</6></li>
</ul>
<p><strong>3.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a364ce5ea7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>插入排序</p>
<p><strong>3.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a474de1ca5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>插入排序Log</p>
<p><strong>四、希尔排序（Shell Sort）</strong></p>
<p>1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。</p>
<p><strong>4.1算法复杂度</strong></p>
<p>时间平均复杂度：O(n^1.3) 最坏复杂度:O(n^2) 最好复杂度: O(n) 空间复杂度: O(1) 不稳定</p>
<p><strong>4.2算法过程描述</strong></p>
<p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li><1>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</1></li>
<li><2>按增量序列个数k，对序列进行k 趟排序；</2></li>
<li><3>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</3></li>
</ul>
<p><strong>4.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a442e8883f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>希尔排序</p>
<p><strong>4.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a339ede12f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>希尔排序Log</p>
<p><strong>五、归并排序（Merge Sort）</strong></p>
<p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。</p>
<p><strong>5.1算法复杂度</strong></p>
<p>时间平均复杂度：O(nlog2^n) 最坏复杂度:O(nlog2^n) 最好复杂度: O(nlog2^n) 空间复杂度: O(n) 稳定</p>
<p><strong>5.2算法过程描述</strong></p>
<ul>
<li><1>把长度为n的输入序列分成两个长度为n/2的子序列；</1></li>
<li><2>对这两个子序列分别采用归并排序；</2></li>
<li><3>将两个排序好的子序列合并成一个最终的排序序列。</3></li>
</ul>
<p><strong>5.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a46985f7b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>归并排序1</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a409882b80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>归并排序2</p>
<p><strong>5.4执行Log信</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a339dbeb27?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>归并排序Log</p>
<p><strong>六、快速排序（Quick Sort）</strong></p>
<p>快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<p><strong>6.1算法复杂度</strong></p>
<p>时间平均复杂度：O(nlog2^n) 最坏复杂度:O(n^2) 最好复杂度: O(nlog2^n) 空间复杂度: O(nlog2^n) 不稳定</p>
<p><strong>6.2算法过程描述</strong></p>
<p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><1>从数列中挑出一个元素，称为 “基准”（pivot）；</1></li>
<li><2>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</2></li>
<li><3>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</3></li>
</ul>
<p><strong>6.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a41db86233?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>快速排序1</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a3ece6622c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>快速排序2</p>
<p><strong>6.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a4133e1133?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>快速排序Log</p>
<p><strong>七、堆排序（Heap Sort）</strong></p>
<p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p><strong>7.1算法复杂度</strong></p>
<p>时间平均复杂度：O(nlog2^n) 最坏复杂度:O(nlog2^n) 最好复杂度: O(nlog2^n) 空间复杂度: O(1) 不稳定</p>
<p><strong>7.2算法过程描述</strong></p>
<ul>
<li><1>将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；</1></li>
<li><2>将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]&lt;=R[n]；</2></li>
<li><3>由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。</3></li>
</ul>
<p><strong>7.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a36ac7d84c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>堆排序1</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a3b0e4324e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>堆排序2</p>
<p><strong>7.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a3b972d3d4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>堆排序Log1</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a339c12d16?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>堆排序Log2</p>
<p><strong>八、计数排序（Counting Sort）</strong></p>
<p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p><strong>8.1算法复杂度</strong></p>
<p>时间平均复杂度：O(n+k) 最坏复杂度:O(n+k) 最好复杂度: O(n+k) 空间复杂度: O(n+k) 稳定</p>
<p><strong>8.2算法过程描述</strong></p>
<ul>
<li><1>找出待排序的数组中最大和最小的元素；</1></li>
<li><2>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</2></li>
<li><3>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</3></li>
<li><4>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</4></li>
</ul>
<p><strong>8.3代码实现</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a33a018720?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>计数排序</p>
<p><strong>8.4执行Log信息</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/9/162a61a33861a77d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>计数排序Log</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/13/Swift-八种排序算法/" data-id="cjh5uw3hz00099mxmpfoafxps" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/05/14/Swift4.0数组（阵列）学习/">4.0数组（阵列）学习</a>
          </li>
        
          <li>
            <a href="/2018/05/14/Swift4.0字典（Dictionary）学习/">4.0字典（Dictionary）学习</a>
          </li>
        
          <li>
            <a href="/2018/05/14/Swift4-0字符串（String）学习/">Swift4.0字符串（String）学习</a>
          </li>
        
          <li>
            <a href="/2018/05/14/Swift4.0数组（Array）之过滤器（过滤器）的使用/">4.0数组（Array）之过滤器（过滤器）的使用</a>
          </li>
        
          <li>
            <a href="/2018/05/14/Swift4.0中的错误处理及抛出错误/">Swift4.0中的错误处理及抛出错误</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>